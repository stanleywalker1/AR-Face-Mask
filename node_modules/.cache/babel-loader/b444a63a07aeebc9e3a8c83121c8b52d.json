{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FaceMesh = exports.getFaceMesh = exports.destroyFaceMesh = exports.createFaceMesh = void 0;\n\nconst gl_matrix_1 = require(\"gl-matrix\");\n\nconst loglevel_1 = require(\"./loglevel\");\n\nlet latestFaceMesh = 1;\nlet faceMeshById = new Map();\n\nfunction createFaceMesh() {\n  let ret = latestFaceMesh++;\n  faceMeshById.set(ret, new FaceMesh());\n  loglevel_1.zcout(\"face_mesh_t initialized\");\n  return ret;\n}\n\nexports.createFaceMesh = createFaceMesh;\n\nfunction destroyFaceMesh(m) {\n  faceMeshById.delete(m);\n}\n\nexports.destroyFaceMesh = destroyFaceMesh;\n\nfunction getFaceMesh(m) {\n  return faceMeshById.get(m);\n}\n\nexports.getFaceMesh = getFaceMesh;\n\nclass FaceMesh {\n  constructor() {\n    this.render_mean_ = new Float32Array();\n    this.render_identity_ = new Float32Array(50);\n    this.render_expression_ = new Float32Array(29);\n    this.render_uvs_ = new Float32Array();\n    this.render_indices_ = new Uint16Array();\n    this.vertices_ = new Float32Array();\n    this.normals_ = new Float32Array();\n    this.normalsCalculated_ = false;\n    this.modelVersion_ = -1;\n    this.mirrored_ = false;\n  }\n\n  loadFromMemory(ab, fillMouth, fillEyeL, fillEyeR, fillNeck) {\n    let offset = 0;\n    let uint16View = new Uint16Array(ab);\n    let intView = new Int32Array(ab);\n    let floatView = new Float32Array(ab);\n\n    let readMatrix = () => {\n      let nr = intView[offset++];\n      let nc = intView[offset++];\n      let size = nr * nc;\n      let ret = floatView.subarray(offset, offset + size);\n      offset += size;\n      return ret;\n    };\n\n    let readShortVector = () => {\n      let size = intView[offset++];\n      let ret = uint16View.subarray(offset * 2, offset * 2 + size);\n      offset += size / 2;\n      return ret;\n    };\n\n    this.render_mean_ = readMatrix();\n    this.render_identity_ = readMatrix();\n    this.render_expression_ = readMatrix();\n    this.render_uvs_ = readMatrix();\n    let baseIndices = readShortVector();\n    let mouthIndices = offset < intView.length ? readShortVector() : new Uint16Array();\n    let leftEyeIndices = offset < intView.length ? readShortVector() : new Uint16Array();\n    let rightEyeIndices = offset < intView.length ? readShortVector() : new Uint16Array();\n    let neckIndices = offset < intView.length ? readShortVector() : new Uint16Array();\n\n    if (!fillMouth && !fillEyeL && !fillEyeR && !fillNeck) {\n      this.render_indices_ = baseIndices;\n    } else {\n      let sizeRequired = baseIndices.length;\n      if (fillMouth) sizeRequired += mouthIndices.length;\n      if (fillEyeL) sizeRequired += leftEyeIndices.length;\n      if (fillEyeR) sizeRequired += rightEyeIndices.length;\n      if (fillNeck) sizeRequired += neckIndices.length;\n      this.render_indices_ = new Uint16Array(sizeRequired);\n      this.render_indices_.set(baseIndices, 0);\n      let indx = baseIndices.length;\n\n      if (fillMouth) {\n        this.render_indices_.set(mouthIndices, indx);\n        indx += mouthIndices.length;\n      }\n\n      if (fillEyeL) {\n        this.render_indices_.set(leftEyeIndices, indx);\n        indx += leftEyeIndices.length;\n      }\n\n      if (fillEyeR) {\n        this.render_indices_.set(rightEyeIndices, indx);\n        indx += rightEyeIndices.length;\n      }\n\n      if (fillNeck) {\n        this.render_indices_.set(neckIndices, indx);\n        indx += neckIndices.length;\n      }\n    }\n\n    this.vertices_ = new Float32Array(this.render_mean_);\n    this.normals_ = new Float32Array(this.vertices_.length);\n    this.modelVersion_++;\n  }\n\n  getVertices() {\n    return this.vertices_;\n  }\n\n  getUVs() {\n    return this.render_uvs_;\n  }\n\n  getIndices() {\n    if (this.mirrored_) {\n      if (!this.render_indices_reversed) {\n        this.render_indices_reversed = new Uint16Array(this.render_indices_.length);\n\n        for (let i = 0; i < this.render_indices_.length; i += 3) {\n          this.render_indices_reversed[i] = this.render_indices_[i + 2];\n          this.render_indices_reversed[i + 1] = this.render_indices_[i + 1];\n          this.render_indices_reversed[i + 2] = this.render_indices_[i];\n        }\n      }\n\n      return this.render_indices_reversed;\n    }\n\n    return this.render_indices_;\n  }\n\n  getNormals() {\n    if (!this.normalsCalculated_) this.calculateNormals();\n    return this.normals_;\n  }\n\n  getModelVersion() {\n    return this.modelVersion_;\n  }\n\n  getLandmarkDataForVertex(v) {\n    let mean = [this.render_mean_[v * 3], this.render_mean_[v * 3 + 1], this.render_mean_[v * 3 + 2]];\n    let identity = [];\n\n    for (let i = 0; i < 50; i++) {\n      identity.push(this.render_identity_[v * 3 * 50 + i]), identity.push(this.render_identity_[(v * 3 + 1) * 50 + i]), identity.push(this.render_identity_[(v * 3 + 2) * 50 + i]);\n    }\n\n    let expression = [];\n\n    for (let i = 0; i < 29; i++) {\n      expression.push(this.render_expression_[v * 3 * 29 + i]), expression.push(this.render_expression_[(v * 3 + 1) * 29 + i]), expression.push(this.render_expression_[(v * 3 + 2) * 29 + i]);\n    }\n\n    return {\n      mean,\n      identity,\n      expression\n    };\n  }\n\n  update(identity, expression, mirrored) {\n    if (this.render_mean_.length === 0) return;\n    if (this.render_identity_.length === 0) return;\n    if (this.render_expression_.length === 0) return;\n    this.mirrored_ = mirrored;\n    this.vertices_.set(this.render_mean_);\n\n    for (let i = 0; i < identity.length; i++) {\n      for (let j = 0; j < this.vertices_.length; j++) {\n        this.vertices_[j] += identity[i] * this.render_identity_[j * identity.length + i];\n      }\n    }\n\n    for (let i = 0; i < expression.length; i++) {\n      for (let j = 0; j < this.vertices_.length; j++) {\n        this.vertices_[j] += expression[i] * this.render_expression_[j * expression.length + i];\n      }\n    }\n\n    if (mirrored) {\n      for (let j = 0; j < this.vertices_.length; j += 3) {\n        this.vertices_[j] *= -1;\n      }\n    }\n\n    this.normalsCalculated_ = false;\n  }\n\n  calculateNormals() {\n    let indices = this.getIndices();\n    let vertices = this.vertices_;\n    let faceNormals = new Float32Array(indices.length);\n    if (!vertices) return;\n    let size = indices.length;\n    let normals = this.normals_;\n    let v = new Float32Array([0, 0, 0]);\n    let w = new Float32Array([0, 0, 0]);\n    let out = new Float32Array([0, 0, 0]);\n\n    for (let i = 0; i < size; i += 3) {\n      let vertexStart0 = indices[i] * 3;\n      let vertexStart1 = indices[i + 1] * 3;\n      let vertexStart2 = indices[i + 2] * 3;\n      v[0] = vertices[vertexStart1] - vertices[vertexStart0];\n      v[1] = vertices[vertexStart1 + 1] - vertices[vertexStart0 + 1];\n      v[2] = vertices[vertexStart1 + 2] - vertices[vertexStart0 + 2];\n      w[0] = vertices[vertexStart2] - vertices[vertexStart0];\n      w[1] = vertices[vertexStart2 + 1] - vertices[vertexStart0 + 1];\n      w[2] = vertices[vertexStart2 + 2] - vertices[vertexStart0 + 2];\n      gl_matrix_1.vec3.cross(out, v, w);\n      let length = gl_matrix_1.vec3.length(out);\n      faceNormals[i] = out[0] / length;\n      faceNormals[i + 1] = out[1] / length;\n      faceNormals[i + 2] = out[2] / length;\n    }\n\n    normals.fill(0);\n\n    for (let i = 0; i < size; i += 3) {\n      let vertexStart0 = indices[i] * 3;\n      let vertexStart1 = indices[i + 1] * 3;\n      let vertexStart2 = indices[i + 2] * 3;\n      normals[vertexStart0] += faceNormals[i];\n      normals[vertexStart0 + 1] += faceNormals[i + 1];\n      normals[vertexStart0 + 2] += faceNormals[i + 2];\n      normals[vertexStart1] += faceNormals[i];\n      normals[vertexStart1 + 1] += faceNormals[i + 1];\n      normals[vertexStart1 + 2] += faceNormals[i + 2];\n      normals[vertexStart2] += faceNormals[i];\n      normals[vertexStart2 + 1] += faceNormals[i + 1];\n      normals[vertexStart2 + 2] += faceNormals[i + 2];\n    }\n\n    let numberNormals = normals.length / 3;\n\n    for (let i = 0; i < numberNormals; i++) {\n      let indx = i * 3;\n      v[0] = normals[indx];\n      v[1] = normals[indx + 1];\n      v[2] = normals[indx + 2];\n      gl_matrix_1.vec3.normalize(w, v);\n      normals[indx] = w[0];\n      normals[indx + 1] = w[1];\n      normals[indx + 2] = w[2];\n    }\n\n    this.normalsCalculated_ = true;\n  }\n\n}\n\nexports.FaceMesh = FaceMesh;","map":{"version":3,"sources":["/Users/StanleyWalker/Desktop/face-mask-demo/AR-Face-Mask/node_modules/@zappar/zappar-cv/lib/facemesh.js"],"names":["Object","defineProperty","exports","value","FaceMesh","getFaceMesh","destroyFaceMesh","createFaceMesh","gl_matrix_1","require","loglevel_1","latestFaceMesh","faceMeshById","Map","ret","set","zcout","m","delete","get","constructor","render_mean_","Float32Array","render_identity_","render_expression_","render_uvs_","render_indices_","Uint16Array","vertices_","normals_","normalsCalculated_","modelVersion_","mirrored_","loadFromMemory","ab","fillMouth","fillEyeL","fillEyeR","fillNeck","offset","uint16View","intView","Int32Array","floatView","readMatrix","nr","nc","size","subarray","readShortVector","baseIndices","mouthIndices","length","leftEyeIndices","rightEyeIndices","neckIndices","sizeRequired","indx","getVertices","getUVs","getIndices","render_indices_reversed","i","getNormals","calculateNormals","getModelVersion","getLandmarkDataForVertex","v","mean","identity","push","expression","update","mirrored","j","indices","vertices","faceNormals","normals","w","out","vertexStart0","vertexStart1","vertexStart2","vec3","cross","fill","numberNormals","normalize"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FaceMesh = exports.getFaceMesh = exports.destroyFaceMesh = exports.createFaceMesh = void 0;\nconst gl_matrix_1 = require(\"gl-matrix\");\nconst loglevel_1 = require(\"./loglevel\");\nlet latestFaceMesh = 1;\nlet faceMeshById = new Map();\nfunction createFaceMesh() {\n    let ret = (latestFaceMesh++);\n    faceMeshById.set(ret, new FaceMesh());\n    loglevel_1.zcout(\"face_mesh_t initialized\");\n    return ret;\n}\nexports.createFaceMesh = createFaceMesh;\nfunction destroyFaceMesh(m) {\n    faceMeshById.delete(m);\n}\nexports.destroyFaceMesh = destroyFaceMesh;\nfunction getFaceMesh(m) {\n    return faceMeshById.get(m);\n}\nexports.getFaceMesh = getFaceMesh;\nclass FaceMesh {\n    constructor() {\n        this.render_mean_ = new Float32Array();\n        this.render_identity_ = new Float32Array(50);\n        this.render_expression_ = new Float32Array(29);\n        this.render_uvs_ = new Float32Array();\n        this.render_indices_ = new Uint16Array();\n        this.vertices_ = new Float32Array();\n        this.normals_ = new Float32Array();\n        this.normalsCalculated_ = false;\n        this.modelVersion_ = -1;\n        this.mirrored_ = false;\n    }\n    loadFromMemory(ab, fillMouth, fillEyeL, fillEyeR, fillNeck) {\n        let offset = 0;\n        let uint16View = new Uint16Array(ab);\n        let intView = new Int32Array(ab);\n        let floatView = new Float32Array(ab);\n        let readMatrix = () => {\n            let nr = intView[offset++];\n            let nc = intView[offset++];\n            let size = nr * nc;\n            let ret = floatView.subarray(offset, offset + size);\n            offset += size;\n            return ret;\n        };\n        let readShortVector = () => {\n            let size = intView[offset++];\n            let ret = uint16View.subarray(offset * 2, offset * 2 + size);\n            offset += size / 2;\n            return ret;\n        };\n        this.render_mean_ = readMatrix();\n        this.render_identity_ = readMatrix();\n        this.render_expression_ = readMatrix();\n        this.render_uvs_ = readMatrix();\n        let baseIndices = readShortVector();\n        let mouthIndices = (offset < intView.length) ? readShortVector() : new Uint16Array();\n        let leftEyeIndices = (offset < intView.length) ? readShortVector() : new Uint16Array();\n        let rightEyeIndices = (offset < intView.length) ? readShortVector() : new Uint16Array();\n        let neckIndices = (offset < intView.length) ? readShortVector() : new Uint16Array();\n        if (!fillMouth && !fillEyeL && !fillEyeR && !fillNeck) {\n            this.render_indices_ = baseIndices;\n        }\n        else {\n            let sizeRequired = baseIndices.length;\n            if (fillMouth)\n                sizeRequired += mouthIndices.length;\n            if (fillEyeL)\n                sizeRequired += leftEyeIndices.length;\n            if (fillEyeR)\n                sizeRequired += rightEyeIndices.length;\n            if (fillNeck)\n                sizeRequired += neckIndices.length;\n            this.render_indices_ = new Uint16Array(sizeRequired);\n            this.render_indices_.set(baseIndices, 0);\n            let indx = baseIndices.length;\n            if (fillMouth) {\n                this.render_indices_.set(mouthIndices, indx);\n                indx += mouthIndices.length;\n            }\n            if (fillEyeL) {\n                this.render_indices_.set(leftEyeIndices, indx);\n                indx += leftEyeIndices.length;\n            }\n            if (fillEyeR) {\n                this.render_indices_.set(rightEyeIndices, indx);\n                indx += rightEyeIndices.length;\n            }\n            if (fillNeck) {\n                this.render_indices_.set(neckIndices, indx);\n                indx += neckIndices.length;\n            }\n        }\n        this.vertices_ = new Float32Array(this.render_mean_);\n        this.normals_ = new Float32Array(this.vertices_.length);\n        this.modelVersion_++;\n    }\n    getVertices() {\n        return this.vertices_;\n    }\n    getUVs() {\n        return this.render_uvs_;\n    }\n    getIndices() {\n        if (this.mirrored_) {\n            if (!this.render_indices_reversed) {\n                this.render_indices_reversed = new Uint16Array(this.render_indices_.length);\n                for (let i = 0; i < this.render_indices_.length; i += 3) {\n                    this.render_indices_reversed[i] = this.render_indices_[i + 2];\n                    this.render_indices_reversed[i + 1] = this.render_indices_[i + 1];\n                    this.render_indices_reversed[i + 2] = this.render_indices_[i];\n                }\n            }\n            return this.render_indices_reversed;\n        }\n        return this.render_indices_;\n    }\n    getNormals() {\n        if (!this.normalsCalculated_)\n            this.calculateNormals();\n        return this.normals_;\n    }\n    getModelVersion() {\n        return this.modelVersion_;\n    }\n    getLandmarkDataForVertex(v) {\n        let mean = [\n            this.render_mean_[v * 3],\n            this.render_mean_[v * 3 + 1],\n            this.render_mean_[v * 3 + 2],\n        ];\n        let identity = [];\n        for (let i = 0; i < 50; i++) {\n            identity.push(this.render_identity_[(v * 3) * 50 + i]),\n                identity.push(this.render_identity_[(v * 3 + 1) * 50 + i]),\n                identity.push(this.render_identity_[(v * 3 + 2) * 50 + i]);\n        }\n        let expression = [];\n        for (let i = 0; i < 29; i++) {\n            expression.push(this.render_expression_[(v * 3) * 29 + i]),\n                expression.push(this.render_expression_[(v * 3 + 1) * 29 + i]),\n                expression.push(this.render_expression_[(v * 3 + 2) * 29 + i]);\n        }\n        return { mean, identity, expression };\n    }\n    update(identity, expression, mirrored) {\n        if (this.render_mean_.length === 0)\n            return;\n        if (this.render_identity_.length === 0)\n            return;\n        if (this.render_expression_.length === 0)\n            return;\n        this.mirrored_ = mirrored;\n        this.vertices_.set(this.render_mean_);\n        for (let i = 0; i < identity.length; i++) {\n            for (let j = 0; j < this.vertices_.length; j++) {\n                this.vertices_[j] += identity[i] * this.render_identity_[j * identity.length + i];\n            }\n        }\n        for (let i = 0; i < expression.length; i++) {\n            for (let j = 0; j < this.vertices_.length; j++) {\n                this.vertices_[j] += expression[i] * this.render_expression_[j * expression.length + i];\n            }\n        }\n        if (mirrored) {\n            for (let j = 0; j < this.vertices_.length; j += 3) {\n                this.vertices_[j] *= -1;\n            }\n        }\n        this.normalsCalculated_ = false;\n    }\n    calculateNormals() {\n        let indices = this.getIndices();\n        let vertices = this.vertices_;\n        let faceNormals = new Float32Array(indices.length);\n        if (!vertices)\n            return;\n        let size = indices.length;\n        let normals = this.normals_;\n        let v = new Float32Array([0, 0, 0]);\n        let w = new Float32Array([0, 0, 0]);\n        let out = new Float32Array([0, 0, 0]);\n        for (let i = 0; i < size; i += 3) {\n            let vertexStart0 = indices[i] * 3;\n            let vertexStart1 = indices[i + 1] * 3;\n            let vertexStart2 = indices[i + 2] * 3;\n            v[0] = vertices[vertexStart1] - vertices[vertexStart0];\n            v[1] = vertices[vertexStart1 + 1] - vertices[vertexStart0 + 1];\n            v[2] = vertices[vertexStart1 + 2] - vertices[vertexStart0 + 2];\n            w[0] = vertices[vertexStart2] - vertices[vertexStart0];\n            w[1] = vertices[vertexStart2 + 1] - vertices[vertexStart0 + 1];\n            w[2] = vertices[vertexStart2 + 2] - vertices[vertexStart0 + 2];\n            gl_matrix_1.vec3.cross(out, v, w);\n            let length = gl_matrix_1.vec3.length(out);\n            faceNormals[i] = out[0] / length;\n            faceNormals[i + 1] = out[1] / length;\n            faceNormals[i + 2] = out[2] / length;\n        }\n        normals.fill(0);\n        for (let i = 0; i < size; i += 3) {\n            let vertexStart0 = indices[i] * 3;\n            let vertexStart1 = indices[i + 1] * 3;\n            let vertexStart2 = indices[i + 2] * 3;\n            normals[vertexStart0] += faceNormals[i];\n            normals[vertexStart0 + 1] += faceNormals[i + 1];\n            normals[vertexStart0 + 2] += faceNormals[i + 2];\n            normals[vertexStart1] += faceNormals[i];\n            normals[vertexStart1 + 1] += faceNormals[i + 1];\n            normals[vertexStart1 + 2] += faceNormals[i + 2];\n            normals[vertexStart2] += faceNormals[i];\n            normals[vertexStart2 + 1] += faceNormals[i + 1];\n            normals[vertexStart2 + 2] += faceNormals[i + 2];\n        }\n        let numberNormals = normals.length / 3;\n        for (let i = 0; i < numberNormals; i++) {\n            let indx = i * 3;\n            v[0] = normals[indx];\n            v[1] = normals[indx + 1];\n            v[2] = normals[indx + 2];\n            gl_matrix_1.vec3.normalize(w, v);\n            normals[indx] = w[0];\n            normals[indx + 1] = w[1];\n            normals[indx + 2] = w[2];\n        }\n        this.normalsCalculated_ = true;\n    }\n}\nexports.FaceMesh = FaceMesh;\n"]},"metadata":{},"sourceType":"script"}