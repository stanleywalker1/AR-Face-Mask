{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HTMLElementSource = void 0;\n\nconst pipeline_1 = require(\"./pipeline\");\n\nconst source_1 = require(\"./source\");\n\nconst profile_1 = require(\"./profile\");\n\nconst shader_1 = require(\"./shader\");\n\nconst gl_matrix_1 = require(\"gl-matrix\");\n\nconst loglevel_1 = require(\"./loglevel\");\n\nconst gl_state_manager_1 = require(\"./gl-state-manager\");\n\nlet latest = 1;\nlet byId = new Map();\n\nclass HTMLElementSource extends source_1.Source {\n  constructor(_video, _pipeline) {\n    super();\n    this._video = _video;\n    this._pipeline = _pipeline;\n    this._isPaused = true;\n    this._hadFrames = false;\n    this._isUserFacing = false;\n    this._cameraToScreenRotation = 0;\n    this._isUploadFrame = true;\n    this._computedTransformRotation = -1;\n    this._computedFrontCameraRotation = false;\n    this._cameraUvTransform = gl_matrix_1.mat4.create();\n    this._cameraVertexTransform = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    this._framebufferWidth = 0;\n    this._framebufferHeight = 0;\n    this._framebufferId = null;\n    this._renderTexture = null;\n    let video = this._video;\n\n    if (this._video instanceof HTMLVideoElement) {\n      video.addEventListener(\"loadedmetadata\", () => {\n        this._hadFrames = true;\n      });\n    } else {\n      this._hadFrames = true;\n    }\n\n    this._resetGLContext = this._resetGLContext.bind(this);\n    let p = pipeline_1.Pipeline.get(this._pipeline);\n    if (p) p.onGLContextReset.bind(this._resetGLContext);\n  }\n\n  static createVideoElementSource(p, element) {\n    let ret = latest++;\n    byId.set(ret, new HTMLElementSource(element, p));\n    loglevel_1.zcout(\"html_element_source_t initialized\");\n    return ret;\n  }\n\n  static getVideoElementSource(m) {\n    return byId.get(m);\n  }\n\n  _resetGLContext() {\n    this._currentVideoTexture = undefined;\n    this._framebufferId = null;\n    this._renderTexture = null;\n    this._vertexBuffer = undefined;\n    this._indexBuffer = undefined;\n    this._greyscaleShader = undefined;\n  }\n\n  destroy() {\n    let p = pipeline_1.Pipeline.get(this._pipeline);\n    if (p) p.onGLContextReset.unbind(this._resetGLContext);\n    this.pause();\n\n    this._resetGLContext();\n  }\n\n  pause() {\n    this._isPaused = true;\n    let p = pipeline_1.Pipeline.get(this._pipeline);\n    if (p && p.currentCameraSource === this) p.currentCameraSource = undefined;\n  }\n\n  start() {\n    var _a;\n\n    if (this._isPaused) {\n      this._isUploadFrame = true;\n      if (this._video instanceof HTMLVideoElement) this._hadFrames = false;\n    }\n\n    this._isPaused = false;\n    let p = pipeline_1.Pipeline.get(this._pipeline);\n\n    if (p && p.currentCameraSource !== this) {\n      (_a = p.currentCameraSource) === null || _a === void 0 ? void 0 : _a.pause();\n      p.currentCameraSource = this;\n    }\n  }\n\n  getFrame(currentlyProcessing) {\n    let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n    if (!pipeline) return;\n    let gl = pipeline.glContext;\n    if (!gl) return;\n    if (this._isPaused) return;\n    if (!this._hadFrames) return;\n\n    try {\n      return this._processFrame(gl, this._cameraToScreenRotation, currentlyProcessing);\n    } catch (ex) {\n      console.log(\"Unable to process frame\");\n    }\n\n    return;\n  }\n\n  _processFrame(gl, rotation, currentlyProcessing) {\n    let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n    if (!pipeline) return undefined;\n\n    if (this._isUploadFrame) {\n      if (!this._currentVideoTexture) {\n        this._currentVideoTexture = pipeline.getVideoTexture();\n      }\n\n      this._uploadFrame(rotation, this._isUserFacing);\n\n      this._isUploadFrame = !this._isUploadFrame;\n      return undefined;\n    }\n\n    if (currentlyProcessing) return undefined;\n    this._isUploadFrame = !this._isUploadFrame;\n    return this._readFrame(pipeline, gl);\n  }\n\n  _uploadFrame(rotation, fc) {\n    if (!this._currentVideoTexture) return;\n    let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n    if (!pipeline) return;\n    let gl = pipeline.glContext;\n    if (!gl) return;\n    const glStateManager = gl_state_manager_1.GLStateManager.get(gl);\n    glStateManager.push();\n    const reenableScissorTest = gl.isEnabled(gl.SCISSOR_TEST);\n    const reenableDepthTest = gl.isEnabled(gl.DEPTH_TEST);\n    const reenableBlend = gl.isEnabled(gl.BLEND);\n    const reenableCullFace = gl.isEnabled(gl.CULL_FACE);\n    const previousActiveTexture = gl.getParameter(gl.ACTIVE_TEXTURE);\n    const previousUnpackFlip = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);\n    const previousProgram = gl.getParameter(gl.CURRENT_PROGRAM);\n    gl.activeTexture(gl.TEXTURE0);\n    const previousBoundTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\n    const previousBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n    const previousBoundArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);\n    const previousBoundElementArrayBuffer = gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING);\n    gl.disable(gl.SCISSOR_TEST);\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.BLEND);\n    gl.disable(gl.CULL_FACE);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n    gl.bindTexture(gl.TEXTURE_2D, this._currentVideoTexture);\n    const level = 0;\n    const internalFormat = gl.RGBA;\n    const srcFormat = gl.RGBA;\n    const srcType = gl.UNSIGNED_BYTE;\n    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, this._video);\n    let videoWidth = 0;\n    let videoHeight = 0;\n\n    if (this._video instanceof HTMLVideoElement) {\n      videoWidth = this._video.videoWidth;\n      videoHeight = this._video.videoHeight;\n    } else {\n      videoWidth = this._video.width;\n      videoHeight = this._video.height;\n    }\n\n    if (videoHeight > videoWidth) videoHeight = [videoWidth, videoWidth = videoHeight][0];\n\n    this._updateTransforms(rotation, fc);\n\n    let framebuffer = this._getFramebuffer(gl, profile_1.profile.dataWidth / 4, profile_1.profile.dataHeight);\n\n    let vbo = this._getVertexBuffer(gl);\n\n    let ibo = this._getIndexBuffer(gl);\n\n    let shader = this._getGreyscaleShader(gl);\n\n    const previousVertexAttribSize = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_SIZE);\n    const previousVertexAttribType = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_TYPE);\n    const previousVertexAttribNormalized = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_NORMALIZED);\n    const previousVertexAttribStride = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_STRIDE);\n    const previousVertexAttribOffset = gl.getVertexAttribOffset(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_POINTER);\n    const previousVertexAttribEnabled = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n    const previousVertexAttribBufferBinding = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING);\n    const previousTextureAttribSize = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_SIZE);\n    const previousTextureAttribType = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_TYPE);\n    const previousTextureAttribNormalized = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_NORMALIZED);\n    const previousTextureAttribStride = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_STRIDE);\n    const previousTextureAttribOffset = gl.getVertexAttribOffset(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_POINTER);\n    const previousTextureAttribEnabled = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n    const previousTextureAttribBufferBinding = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING); // Rendering to the greyscale conversion buffer - bind the framebuffer\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); // const t_before = performance.now();\n    // const viewport = gl.getParameter(gl.VIEWPORT);\n    // console.log(\"Viewport time\", performance.now() - t_before, viewport);\n\n    gl.viewport(0, 0, this._framebufferWidth, this._framebufferHeight); // We'll be replacing all the content - clear is a good hint for this on mobile\n\n    gl.clear(gl.COLOR_BUFFER_BIT); // Set up bindings for vertex attributes\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n    gl.vertexAttribPointer(shader.aVertexPositionLoc, 2, gl.FLOAT, false, 4 * 4, 0);\n    gl.enableVertexAttribArray(shader.aVertexPositionLoc);\n    gl.vertexAttribPointer(shader.aTextureCoordLoc, 2, gl.FLOAT, false, 4 * 4, 2 * 4);\n    gl.enableVertexAttribArray(shader.aTextureCoordLoc); // Bind the index buffer\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo); // Tell WebGL to use our program when drawing\n\n    gl.useProgram(shader.program); // Specify greyscale width for the correct offsets, and the uv transform\n\n    gl.uniform1f(shader.uTexWidthLoc, profile_1.profile.dataWidth);\n    gl.uniformMatrix4fv(shader.uUvTransformLoc, false, this._cameraUvTransform);\n    gl.activeTexture(gl.TEXTURE0); // Bind the texture to texture unit 0\n\n    gl.bindTexture(gl.TEXTURE_2D, this._currentVideoTexture); // Tell the shader we bound the texture to texture unit 0\n\n    gl.uniform1i(shader.uSamplerLoc, 0); // Do the drawing...\n\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n    gl.bindBuffer(gl.ARRAY_BUFFER, previousVertexAttribBufferBinding);\n    gl.vertexAttribPointer(shader.aVertexPositionLoc, previousVertexAttribSize, previousVertexAttribType, previousVertexAttribNormalized, previousVertexAttribStride, previousVertexAttribOffset);\n    gl.bindBuffer(gl.ARRAY_BUFFER, previousTextureAttribBufferBinding);\n    gl.vertexAttribPointer(shader.aTextureCoordLoc, previousTextureAttribSize, previousTextureAttribType, previousTextureAttribNormalized, previousTextureAttribStride, previousTextureAttribOffset);\n    gl.bindBuffer(gl.ARRAY_BUFFER, previousBoundArrayBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, previousBoundElementArrayBuffer);\n    if (!previousVertexAttribEnabled) gl.disableVertexAttribArray(shader.aVertexPositionLoc);\n    if (!previousTextureAttribEnabled) gl.disableVertexAttribArray(shader.aTextureCoordLoc);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, previousBoundFramebuffer);\n    gl.useProgram(previousProgram);\n    gl.bindTexture(gl.TEXTURE_2D, previousBoundTexture);\n    gl.activeTexture(previousActiveTexture);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, previousUnpackFlip);\n    if (reenableBlend) gl.enable(gl.BLEND);\n    if (reenableCullFace) gl.enable(gl.CULL_FACE);\n    if (reenableDepthTest) gl.enable(gl.DEPTH_TEST);\n    if (reenableScissorTest) gl.enable(gl.SCISSOR_TEST);\n    glStateManager.pop();\n  }\n\n  _readFrame(p, gl) {\n    if (!this._currentVideoTexture) throw new Error(\"No video texture\");\n    let tex = this._currentVideoTexture;\n    this._currentVideoTexture = undefined;\n    let greySize = profile_1.profile.dataWidth * profile_1.profile.dataHeight;\n    let pixels = p.cameraPixelArrays.pop();\n\n    while (pixels) {\n      if (pixels.byteLength === greySize) break;\n      pixels = p.cameraPixelArrays.pop();\n    }\n\n    if (!pixels) {\n      pixels = new ArrayBuffer(greySize);\n    }\n\n    let pixelsView = new Uint8Array(pixels);\n    const previousBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n\n    let framebuffer = this._getFramebuffer(gl, profile_1.profile.dataWidth / 4, profile_1.profile.dataHeight);\n\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.readPixels(0, 0, this._framebufferWidth, this._framebufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixelsView);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, previousBoundFramebuffer);\n    return {\n      uvTransform: this._cameraUvTransform,\n      data: pixels,\n      texture: tex,\n      dataWidth: profile_1.profile.dataWidth,\n      dataHeight: profile_1.profile.dataHeight,\n      userFacing: this._computedFrontCameraRotation\n    };\n  }\n\n  _updateTransforms(rot, fc) {\n    if (rot == this._computedTransformRotation && fc == this._computedFrontCameraRotation) return;\n    this._computedTransformRotation = rot;\n    this._computedFrontCameraRotation = fc;\n    this._cameraUvTransform = this._getCameraUvTransform();\n    this._cameraVertexTransform = this._getCameraVertexTransform();\n  }\n\n  _getCameraUvTransform() {\n    switch (this._computedTransformRotation) {\n      case 270:\n        return new Float32Array([0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1]);\n\n      case 180:\n        return new Float32Array([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);\n\n      case 90:\n        return new Float32Array([0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1]);\n    }\n\n    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n\n  _getCameraVertexTransform() {\n    let identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    if (!this._computedFrontCameraRotation) return identity; // It's a little odd there's only one special case here.\n    // This is because the camera rotation should really depend on\n    // isFrontCamera as well; we should aim to rotate the camera to\n    // process it in sensor-native orientation and then rotate and\n    // flip for rendering based on the screen orientation.\n    // For now I've kept with the rotation values calculated for the\n    // rear camera and correct the rendering of the front camera here\n    // for all rotations (tested on iPad which allows inverse\n    // portrait).\n    // TODO: Figure this out correctly. Probably need to do this to\n    // correctly use accelerometer / gyro data alongside vision data\n    // regardless of orientation\n\n    switch (this._computedTransformRotation) {\n      case 0:\n      case 90:\n      case 180:\n        identity[0] = -1;\n        break;\n\n      case 270:\n        identity[5] = -1;\n        break;\n    }\n\n    return identity;\n  }\n\n  _getFramebuffer(gl, fbWidth, fbHeight) {\n    if (this._framebufferWidth === fbWidth && this._framebufferHeight === fbHeight && this._framebufferId) return this._framebufferId;\n\n    if (this._framebufferId) {\n      gl.deleteFramebuffer(this._framebufferId);\n      this._framebufferId = null;\n    }\n\n    if (this._renderTexture) {\n      gl.deleteTexture(this._renderTexture);\n      this._renderTexture = null;\n    }\n\n    this._framebufferId = gl.createFramebuffer();\n    if (!this._framebufferId) throw new Error(\"Unable to create framebuffer\");\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebufferId);\n    this._renderTexture = gl.createTexture();\n    if (!this._renderTexture) throw new Error(\"Unable to create render texture\");\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this._renderTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fbWidth, fbHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._renderTexture, 0);\n    let fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if (fbStatus !== gl.FRAMEBUFFER_COMPLETE) throw new Error(\"Framebuffer not complete: \" + fbStatus.toString());\n    this._framebufferWidth = fbWidth;\n    this._framebufferHeight = fbHeight;\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return this._framebufferId;\n  }\n\n  _getVertexBuffer(gl) {\n    if (this._vertexBuffer) return this._vertexBuffer;\n    this._vertexBuffer = gl.createBuffer();\n    if (!this._vertexBuffer) throw new Error(\"Unable to create vertex buffer\");\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);\n    let buffer = new Float32Array([-1.0, -1.0, 0.0, 0.0, -1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 0.0]);\n    gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);\n    return this._vertexBuffer;\n  }\n\n  _getIndexBuffer(gl) {\n    if (this._indexBuffer) return this._indexBuffer;\n    this._indexBuffer = gl.createBuffer();\n    if (!this._indexBuffer) throw new Error(\"Unable to create index buffer\");\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);\n    let buffer = new Uint16Array([0, 1, 2, 0, 2, 3]);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, buffer, gl.STATIC_DRAW);\n    return this._indexBuffer;\n  }\n\n  _getGreyscaleShader(gl) {\n    if (this._greyscaleShader) return this._greyscaleShader;\n    let prog = gl.createProgram();\n    if (!prog) throw new Error(\"Unable to create program\");\n    let vertexShader = shader_1.compileShader(gl, gl.VERTEX_SHADER, greyscaleVsSource);\n    let fragmentShader = shader_1.compileShader(gl, gl.FRAGMENT_SHADER, greyscaleFsSource);\n    gl.attachShader(prog, vertexShader);\n    gl.attachShader(prog, fragmentShader);\n    shader_1.linkProgram(gl, prog);\n    let uTexWidthLoc = gl.getUniformLocation(prog, \"uTexWidth\");\n    if (!uTexWidthLoc) throw new Error(\"Unable to get uniform location uTexWidth\");\n    let uUvTransformLoc = gl.getUniformLocation(prog, \"uUvTransform\");\n    if (!uUvTransformLoc) throw new Error(\"Unable to get uniform location uUvTransform\");\n    let uSamplerLoc = gl.getUniformLocation(prog, \"uSampler\");\n    if (!uSamplerLoc) throw new Error(\"Unable to get uniform location uSampler\");\n    this._greyscaleShader = {\n      program: prog,\n      aVertexPositionLoc: gl.getAttribLocation(prog, \"aVertexPosition\"),\n      aTextureCoordLoc: gl.getAttribLocation(prog, \"aTextureCoord\"),\n      uTexWidthLoc: uTexWidthLoc,\n      uUvTransformLoc: uUvTransformLoc,\n      uSamplerLoc: uSamplerLoc\n    };\n    return this._greyscaleShader;\n  }\n\n}\n\nexports.HTMLElementSource = HTMLElementSource;\nlet greyscaleVsSource = `\n    attribute vec4 aVertexPosition;\n    attribute vec2 aTextureCoord;\n\n    varying highp vec2 vTextureCoord1;\n    varying highp vec2 vTextureCoord2;\n    varying highp vec2 vTextureCoord3;\n    varying highp vec2 vTextureCoord4;\n\n    uniform float uTexWidth;\n\tuniform mat4 uUvTransform;\n\n    void main(void) {\n      highp vec2 offset1 = vec2(1.5 / uTexWidth, 0);\n      highp vec2 offset2 = vec2(0.5 / uTexWidth, 0);\n\n      gl_Position = aVertexPosition;\n      vTextureCoord1 = (uUvTransform * vec4(aTextureCoord - offset1, 0, 1)).xy;\n      vTextureCoord2 = (uUvTransform * vec4(aTextureCoord - offset2, 0, 1)).xy;\n      vTextureCoord3 = (uUvTransform * vec4(aTextureCoord + offset2, 0, 1)).xy;\n      vTextureCoord4 = (uUvTransform * vec4(aTextureCoord + offset1, 0, 1)).xy;\n    }\n`; // Fragment shader program\n\nlet greyscaleFsSource = `\n  varying highp vec2 vTextureCoord1;\n  varying highp vec2 vTextureCoord2;\n  varying highp vec2 vTextureCoord3;\n  varying highp vec2 vTextureCoord4;\n\n  uniform sampler2D uSampler;\n\n  const lowp vec3 colorWeights = vec3(77.0 / 256.0, 150.0 / 256.0, 29.0 / 256.0);\n\n  void main(void) {\n    lowp vec4 outpx;\n\n    outpx.r = dot(colorWeights, texture2D(uSampler, vTextureCoord1).xyz);\n    outpx.g = dot(colorWeights, texture2D(uSampler, vTextureCoord2).xyz);\n    outpx.b = dot(colorWeights, texture2D(uSampler, vTextureCoord3).xyz);\n    outpx.a = dot(colorWeights, texture2D(uSampler, vTextureCoord4).xyz);\n\n    gl_FragColor = outpx;\n  }\n`;","map":{"version":3,"sources":["/Users/StanleyWalker/Desktop/face-mask-demo/AR-Face-Mask/node_modules/@zappar/zappar-cv/lib/html-element-source.js"],"names":["Object","defineProperty","exports","value","HTMLElementSource","pipeline_1","require","source_1","profile_1","shader_1","gl_matrix_1","loglevel_1","gl_state_manager_1","latest","byId","Map","Source","constructor","_video","_pipeline","_isPaused","_hadFrames","_isUserFacing","_cameraToScreenRotation","_isUploadFrame","_computedTransformRotation","_computedFrontCameraRotation","_cameraUvTransform","mat4","create","_cameraVertexTransform","_framebufferWidth","_framebufferHeight","_framebufferId","_renderTexture","video","HTMLVideoElement","addEventListener","_resetGLContext","bind","p","Pipeline","get","onGLContextReset","createVideoElementSource","element","ret","set","zcout","getVideoElementSource","m","_currentVideoTexture","undefined","_vertexBuffer","_indexBuffer","_greyscaleShader","destroy","unbind","pause","currentCameraSource","start","_a","getFrame","currentlyProcessing","pipeline","gl","glContext","_processFrame","ex","console","log","rotation","getVideoTexture","_uploadFrame","_readFrame","fc","glStateManager","GLStateManager","push","reenableScissorTest","isEnabled","SCISSOR_TEST","reenableDepthTest","DEPTH_TEST","reenableBlend","BLEND","reenableCullFace","CULL_FACE","previousActiveTexture","getParameter","ACTIVE_TEXTURE","previousUnpackFlip","UNPACK_FLIP_Y_WEBGL","previousProgram","CURRENT_PROGRAM","activeTexture","TEXTURE0","previousBoundTexture","TEXTURE_BINDING_2D","previousBoundFramebuffer","FRAMEBUFFER_BINDING","previousBoundArrayBuffer","ARRAY_BUFFER_BINDING","previousBoundElementArrayBuffer","ELEMENT_ARRAY_BUFFER_BINDING","disable","pixelStorei","bindTexture","TEXTURE_2D","level","internalFormat","RGBA","srcFormat","srcType","UNSIGNED_BYTE","texImage2D","videoWidth","videoHeight","width","height","_updateTransforms","framebuffer","_getFramebuffer","profile","dataWidth","dataHeight","vbo","_getVertexBuffer","ibo","_getIndexBuffer","shader","_getGreyscaleShader","previousVertexAttribSize","getVertexAttrib","aVertexPositionLoc","VERTEX_ATTRIB_ARRAY_SIZE","previousVertexAttribType","VERTEX_ATTRIB_ARRAY_TYPE","previousVertexAttribNormalized","VERTEX_ATTRIB_ARRAY_NORMALIZED","previousVertexAttribStride","VERTEX_ATTRIB_ARRAY_STRIDE","previousVertexAttribOffset","getVertexAttribOffset","VERTEX_ATTRIB_ARRAY_POINTER","previousVertexAttribEnabled","VERTEX_ATTRIB_ARRAY_ENABLED","previousVertexAttribBufferBinding","VERTEX_ATTRIB_ARRAY_BUFFER_BINDING","previousTextureAttribSize","aTextureCoordLoc","previousTextureAttribType","previousTextureAttribNormalized","previousTextureAttribStride","previousTextureAttribOffset","previousTextureAttribEnabled","previousTextureAttribBufferBinding","bindFramebuffer","FRAMEBUFFER","viewport","clear","COLOR_BUFFER_BIT","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","enableVertexAttribArray","ELEMENT_ARRAY_BUFFER","useProgram","program","uniform1f","uTexWidthLoc","uniformMatrix4fv","uUvTransformLoc","uniform1i","uSamplerLoc","drawElements","TRIANGLES","UNSIGNED_SHORT","disableVertexAttribArray","enable","pop","Error","tex","greySize","pixels","cameraPixelArrays","byteLength","ArrayBuffer","pixelsView","Uint8Array","readPixels","uvTransform","data","texture","userFacing","rot","_getCameraUvTransform","_getCameraVertexTransform","Float32Array","identity","fbWidth","fbHeight","deleteFramebuffer","deleteTexture","createFramebuffer","createTexture","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","texParameterf","TEXTURE_MIN_FILTER","LINEAR","framebufferTexture2D","COLOR_ATTACHMENT0","fbStatus","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","toString","createBuffer","buffer","bufferData","STATIC_DRAW","Uint16Array","prog","createProgram","vertexShader","compileShader","VERTEX_SHADER","greyscaleVsSource","fragmentShader","FRAGMENT_SHADER","greyscaleFsSource","attachShader","linkProgram","getUniformLocation","getAttribLocation"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HTMLElementSource = void 0;\nconst pipeline_1 = require(\"./pipeline\");\nconst source_1 = require(\"./source\");\nconst profile_1 = require(\"./profile\");\nconst shader_1 = require(\"./shader\");\nconst gl_matrix_1 = require(\"gl-matrix\");\nconst loglevel_1 = require(\"./loglevel\");\nconst gl_state_manager_1 = require(\"./gl-state-manager\");\nlet latest = 1;\nlet byId = new Map();\nclass HTMLElementSource extends source_1.Source {\n    constructor(_video, _pipeline) {\n        super();\n        this._video = _video;\n        this._pipeline = _pipeline;\n        this._isPaused = true;\n        this._hadFrames = false;\n        this._isUserFacing = false;\n        this._cameraToScreenRotation = 0;\n        this._isUploadFrame = true;\n        this._computedTransformRotation = -1;\n        this._computedFrontCameraRotation = false;\n        this._cameraUvTransform = gl_matrix_1.mat4.create();\n        this._cameraVertexTransform = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n        this._framebufferWidth = 0;\n        this._framebufferHeight = 0;\n        this._framebufferId = null;\n        this._renderTexture = null;\n        let video = this._video;\n        if (this._video instanceof HTMLVideoElement) {\n            video.addEventListener(\"loadedmetadata\", () => { this._hadFrames = true; });\n        }\n        else {\n            this._hadFrames = true;\n        }\n        this._resetGLContext = this._resetGLContext.bind(this);\n        let p = pipeline_1.Pipeline.get(this._pipeline);\n        if (p)\n            p.onGLContextReset.bind(this._resetGLContext);\n    }\n    static createVideoElementSource(p, element) {\n        let ret = (latest++);\n        byId.set(ret, new HTMLElementSource(element, p));\n        loglevel_1.zcout(\"html_element_source_t initialized\");\n        return ret;\n    }\n    static getVideoElementSource(m) {\n        return byId.get(m);\n    }\n    _resetGLContext() {\n        this._currentVideoTexture = undefined;\n        this._framebufferId = null;\n        this._renderTexture = null;\n        this._vertexBuffer = undefined;\n        this._indexBuffer = undefined;\n        this._greyscaleShader = undefined;\n    }\n    destroy() {\n        let p = pipeline_1.Pipeline.get(this._pipeline);\n        if (p)\n            p.onGLContextReset.unbind(this._resetGLContext);\n        this.pause();\n        this._resetGLContext();\n    }\n    pause() {\n        this._isPaused = true;\n        let p = pipeline_1.Pipeline.get(this._pipeline);\n        if (p && p.currentCameraSource === this)\n            p.currentCameraSource = undefined;\n    }\n    start() {\n        var _a;\n        if (this._isPaused) {\n            this._isUploadFrame = true;\n            if (this._video instanceof HTMLVideoElement)\n                this._hadFrames = false;\n        }\n        this._isPaused = false;\n        let p = pipeline_1.Pipeline.get(this._pipeline);\n        if (p && p.currentCameraSource !== this) {\n            (_a = p.currentCameraSource) === null || _a === void 0 ? void 0 : _a.pause();\n            p.currentCameraSource = this;\n        }\n    }\n    getFrame(currentlyProcessing) {\n        let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n        if (!pipeline)\n            return;\n        let gl = pipeline.glContext;\n        if (!gl)\n            return;\n        if (this._isPaused)\n            return;\n        if (!this._hadFrames)\n            return;\n        try {\n            return this._processFrame(gl, this._cameraToScreenRotation, currentlyProcessing);\n        }\n        catch (ex) {\n            console.log(\"Unable to process frame\");\n        }\n        return;\n    }\n    _processFrame(gl, rotation, currentlyProcessing) {\n        let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n        if (!pipeline)\n            return undefined;\n        if (this._isUploadFrame) {\n            if (!this._currentVideoTexture) {\n                this._currentVideoTexture = pipeline.getVideoTexture();\n            }\n            this._uploadFrame(rotation, this._isUserFacing);\n            this._isUploadFrame = !this._isUploadFrame;\n            return undefined;\n        }\n        if (currentlyProcessing)\n            return undefined;\n        this._isUploadFrame = !this._isUploadFrame;\n        return this._readFrame(pipeline, gl);\n    }\n    _uploadFrame(rotation, fc) {\n        if (!this._currentVideoTexture)\n            return;\n        let pipeline = pipeline_1.Pipeline.get(this._pipeline);\n        if (!pipeline)\n            return;\n        let gl = pipeline.glContext;\n        if (!gl)\n            return;\n        const glStateManager = gl_state_manager_1.GLStateManager.get(gl);\n        glStateManager.push();\n        const reenableScissorTest = gl.isEnabled(gl.SCISSOR_TEST);\n        const reenableDepthTest = gl.isEnabled(gl.DEPTH_TEST);\n        const reenableBlend = gl.isEnabled(gl.BLEND);\n        const reenableCullFace = gl.isEnabled(gl.CULL_FACE);\n        const previousActiveTexture = gl.getParameter(gl.ACTIVE_TEXTURE);\n        const previousUnpackFlip = gl.getParameter(gl.UNPACK_FLIP_Y_WEBGL);\n        const previousProgram = gl.getParameter(gl.CURRENT_PROGRAM);\n        gl.activeTexture(gl.TEXTURE0);\n        const previousBoundTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\n        const previousBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n        const previousBoundArrayBuffer = gl.getParameter(gl.ARRAY_BUFFER_BINDING);\n        const previousBoundElementArrayBuffer = gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING);\n        gl.disable(gl.SCISSOR_TEST);\n        gl.disable(gl.DEPTH_TEST);\n        gl.disable(gl.BLEND);\n        gl.disable(gl.CULL_FACE);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n        gl.bindTexture(gl.TEXTURE_2D, this._currentVideoTexture);\n        const level = 0;\n        const internalFormat = gl.RGBA;\n        const srcFormat = gl.RGBA;\n        const srcType = gl.UNSIGNED_BYTE;\n        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, this._video);\n        let videoWidth = 0;\n        let videoHeight = 0;\n        if (this._video instanceof HTMLVideoElement) {\n            videoWidth = this._video.videoWidth;\n            videoHeight = this._video.videoHeight;\n        }\n        else {\n            videoWidth = this._video.width;\n            videoHeight = this._video.height;\n        }\n        if (videoHeight > videoWidth)\n            videoHeight = [videoWidth, videoWidth = videoHeight][0];\n        this._updateTransforms(rotation, fc);\n        let framebuffer = this._getFramebuffer(gl, profile_1.profile.dataWidth / 4, profile_1.profile.dataHeight);\n        let vbo = this._getVertexBuffer(gl);\n        let ibo = this._getIndexBuffer(gl);\n        let shader = this._getGreyscaleShader(gl);\n        const previousVertexAttribSize = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_SIZE);\n        const previousVertexAttribType = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_TYPE);\n        const previousVertexAttribNormalized = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_NORMALIZED);\n        const previousVertexAttribStride = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_STRIDE);\n        const previousVertexAttribOffset = gl.getVertexAttribOffset(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_POINTER);\n        const previousVertexAttribEnabled = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n        const previousVertexAttribBufferBinding = gl.getVertexAttrib(shader.aVertexPositionLoc, gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING);\n        const previousTextureAttribSize = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_SIZE);\n        const previousTextureAttribType = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_TYPE);\n        const previousTextureAttribNormalized = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_NORMALIZED);\n        const previousTextureAttribStride = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_STRIDE);\n        const previousTextureAttribOffset = gl.getVertexAttribOffset(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_POINTER);\n        const previousTextureAttribEnabled = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_ENABLED);\n        const previousTextureAttribBufferBinding = gl.getVertexAttrib(shader.aTextureCoordLoc, gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING);\n        // Rendering to the greyscale conversion buffer - bind the framebuffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        // const t_before = performance.now();\n        // const viewport = gl.getParameter(gl.VIEWPORT);\n        // console.log(\"Viewport time\", performance.now() - t_before, viewport);\n        gl.viewport(0, 0, this._framebufferWidth, this._framebufferHeight);\n        // We'll be replacing all the content - clear is a good hint for this on mobile\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        // Set up bindings for vertex attributes\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n        gl.vertexAttribPointer(shader.aVertexPositionLoc, 2, gl.FLOAT, false, 4 * 4, 0);\n        gl.enableVertexAttribArray(shader.aVertexPositionLoc);\n        gl.vertexAttribPointer(shader.aTextureCoordLoc, 2, gl.FLOAT, false, 4 * 4, 2 * 4);\n        gl.enableVertexAttribArray(shader.aTextureCoordLoc);\n        // Bind the index buffer\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);\n        // Tell WebGL to use our program when drawing\n        gl.useProgram(shader.program);\n        // Specify greyscale width for the correct offsets, and the uv transform\n        gl.uniform1f(shader.uTexWidthLoc, profile_1.profile.dataWidth);\n        gl.uniformMatrix4fv(shader.uUvTransformLoc, false, this._cameraUvTransform);\n        gl.activeTexture(gl.TEXTURE0);\n        // Bind the texture to texture unit 0\n        gl.bindTexture(gl.TEXTURE_2D, this._currentVideoTexture);\n        // Tell the shader we bound the texture to texture unit 0\n        gl.uniform1i(shader.uSamplerLoc, 0);\n        // Do the drawing...\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n        gl.bindBuffer(gl.ARRAY_BUFFER, previousVertexAttribBufferBinding);\n        gl.vertexAttribPointer(shader.aVertexPositionLoc, previousVertexAttribSize, previousVertexAttribType, previousVertexAttribNormalized, previousVertexAttribStride, previousVertexAttribOffset);\n        gl.bindBuffer(gl.ARRAY_BUFFER, previousTextureAttribBufferBinding);\n        gl.vertexAttribPointer(shader.aTextureCoordLoc, previousTextureAttribSize, previousTextureAttribType, previousTextureAttribNormalized, previousTextureAttribStride, previousTextureAttribOffset);\n        gl.bindBuffer(gl.ARRAY_BUFFER, previousBoundArrayBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, previousBoundElementArrayBuffer);\n        if (!previousVertexAttribEnabled)\n            gl.disableVertexAttribArray(shader.aVertexPositionLoc);\n        if (!previousTextureAttribEnabled)\n            gl.disableVertexAttribArray(shader.aTextureCoordLoc);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, previousBoundFramebuffer);\n        gl.useProgram(previousProgram);\n        gl.bindTexture(gl.TEXTURE_2D, previousBoundTexture);\n        gl.activeTexture(previousActiveTexture);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, previousUnpackFlip);\n        if (reenableBlend)\n            gl.enable(gl.BLEND);\n        if (reenableCullFace)\n            gl.enable(gl.CULL_FACE);\n        if (reenableDepthTest)\n            gl.enable(gl.DEPTH_TEST);\n        if (reenableScissorTest)\n            gl.enable(gl.SCISSOR_TEST);\n        glStateManager.pop();\n    }\n    _readFrame(p, gl) {\n        if (!this._currentVideoTexture)\n            throw new Error(\"No video texture\");\n        let tex = this._currentVideoTexture;\n        this._currentVideoTexture = undefined;\n        let greySize = profile_1.profile.dataWidth * profile_1.profile.dataHeight;\n        let pixels = p.cameraPixelArrays.pop();\n        while (pixels) {\n            if (pixels.byteLength === greySize)\n                break;\n            pixels = p.cameraPixelArrays.pop();\n        }\n        if (!pixels) {\n            pixels = new ArrayBuffer(greySize);\n        }\n        let pixelsView = new Uint8Array(pixels);\n        const previousBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);\n        let framebuffer = this._getFramebuffer(gl, profile_1.profile.dataWidth / 4, profile_1.profile.dataHeight);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.readPixels(0, 0, this._framebufferWidth, this._framebufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixelsView);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, previousBoundFramebuffer);\n        return {\n            uvTransform: this._cameraUvTransform,\n            data: pixels,\n            texture: tex,\n            dataWidth: profile_1.profile.dataWidth,\n            dataHeight: profile_1.profile.dataHeight,\n            userFacing: this._computedFrontCameraRotation\n        };\n    }\n    _updateTransforms(rot, fc) {\n        if (rot == this._computedTransformRotation && fc == this._computedFrontCameraRotation)\n            return;\n        this._computedTransformRotation = rot;\n        this._computedFrontCameraRotation = fc;\n        this._cameraUvTransform = this._getCameraUvTransform();\n        this._cameraVertexTransform = this._getCameraVertexTransform();\n    }\n    _getCameraUvTransform() {\n        switch (this._computedTransformRotation) {\n            case 270: return new Float32Array([0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1]);\n            case 180: return new Float32Array([-1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1]);\n            case 90: return new Float32Array([0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1]);\n        }\n        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    }\n    _getCameraVertexTransform() {\n        let identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n        if (!this._computedFrontCameraRotation)\n            return identity;\n        // It's a little odd there's only one special case here.\n        // This is because the camera rotation should really depend on\n        // isFrontCamera as well; we should aim to rotate the camera to\n        // process it in sensor-native orientation and then rotate and\n        // flip for rendering based on the screen orientation.\n        // For now I've kept with the rotation values calculated for the\n        // rear camera and correct the rendering of the front camera here\n        // for all rotations (tested on iPad which allows inverse\n        // portrait).\n        // TODO: Figure this out correctly. Probably need to do this to\n        // correctly use accelerometer / gyro data alongside vision data\n        // regardless of orientation\n        switch (this._computedTransformRotation) {\n            case 0:\n            case 90:\n            case 180:\n                identity[0] = -1;\n                break;\n            case 270:\n                identity[5] = -1;\n                break;\n        }\n        return identity;\n    }\n    _getFramebuffer(gl, fbWidth, fbHeight) {\n        if (this._framebufferWidth === fbWidth && this._framebufferHeight === fbHeight && this._framebufferId)\n            return this._framebufferId;\n        if (this._framebufferId) {\n            gl.deleteFramebuffer(this._framebufferId);\n            this._framebufferId = null;\n        }\n        if (this._renderTexture) {\n            gl.deleteTexture(this._renderTexture);\n            this._renderTexture = null;\n        }\n        this._framebufferId = gl.createFramebuffer();\n        if (!this._framebufferId)\n            throw new Error(\"Unable to create framebuffer\");\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebufferId);\n        this._renderTexture = gl.createTexture();\n        if (!this._renderTexture)\n            throw new Error(\"Unable to create render texture\");\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, this._renderTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, fbWidth, fbHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._renderTexture, 0);\n        let fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        if (fbStatus !== gl.FRAMEBUFFER_COMPLETE)\n            throw new Error(\"Framebuffer not complete: \" + fbStatus.toString());\n        this._framebufferWidth = fbWidth;\n        this._framebufferHeight = fbHeight;\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return this._framebufferId;\n    }\n    _getVertexBuffer(gl) {\n        if (this._vertexBuffer)\n            return this._vertexBuffer;\n        this._vertexBuffer = gl.createBuffer();\n        if (!this._vertexBuffer)\n            throw new Error(\"Unable to create vertex buffer\");\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);\n        let buffer = new Float32Array([-1.0, -1.0, 0.0, 0.0,\n            -1.0, 1.0, 0.0, 1.0,\n            1.0, 1.0, 1.0, 1.0,\n            1.0, -1.0, 1.0, 0.0]);\n        gl.bufferData(gl.ARRAY_BUFFER, buffer, gl.STATIC_DRAW);\n        return this._vertexBuffer;\n    }\n    _getIndexBuffer(gl) {\n        if (this._indexBuffer)\n            return this._indexBuffer;\n        this._indexBuffer = gl.createBuffer();\n        if (!this._indexBuffer)\n            throw new Error(\"Unable to create index buffer\");\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);\n        let buffer = new Uint16Array([0, 1, 2, 0, 2, 3]);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, buffer, gl.STATIC_DRAW);\n        return this._indexBuffer;\n    }\n    _getGreyscaleShader(gl) {\n        if (this._greyscaleShader)\n            return this._greyscaleShader;\n        let prog = gl.createProgram();\n        if (!prog)\n            throw new Error(\"Unable to create program\");\n        let vertexShader = shader_1.compileShader(gl, gl.VERTEX_SHADER, greyscaleVsSource);\n        let fragmentShader = shader_1.compileShader(gl, gl.FRAGMENT_SHADER, greyscaleFsSource);\n        gl.attachShader(prog, vertexShader);\n        gl.attachShader(prog, fragmentShader);\n        shader_1.linkProgram(gl, prog);\n        let uTexWidthLoc = gl.getUniformLocation(prog, \"uTexWidth\");\n        if (!uTexWidthLoc)\n            throw new Error(\"Unable to get uniform location uTexWidth\");\n        let uUvTransformLoc = gl.getUniformLocation(prog, \"uUvTransform\");\n        if (!uUvTransformLoc)\n            throw new Error(\"Unable to get uniform location uUvTransform\");\n        let uSamplerLoc = gl.getUniformLocation(prog, \"uSampler\");\n        if (!uSamplerLoc)\n            throw new Error(\"Unable to get uniform location uSampler\");\n        this._greyscaleShader = {\n            program: prog,\n            aVertexPositionLoc: gl.getAttribLocation(prog, \"aVertexPosition\"),\n            aTextureCoordLoc: gl.getAttribLocation(prog, \"aTextureCoord\"),\n            uTexWidthLoc: uTexWidthLoc,\n            uUvTransformLoc: uUvTransformLoc,\n            uSamplerLoc: uSamplerLoc\n        };\n        return this._greyscaleShader;\n    }\n}\nexports.HTMLElementSource = HTMLElementSource;\nlet greyscaleVsSource = `\n    attribute vec4 aVertexPosition;\n    attribute vec2 aTextureCoord;\n\n    varying highp vec2 vTextureCoord1;\n    varying highp vec2 vTextureCoord2;\n    varying highp vec2 vTextureCoord3;\n    varying highp vec2 vTextureCoord4;\n\n    uniform float uTexWidth;\n\tuniform mat4 uUvTransform;\n\n    void main(void) {\n      highp vec2 offset1 = vec2(1.5 / uTexWidth, 0);\n      highp vec2 offset2 = vec2(0.5 / uTexWidth, 0);\n\n      gl_Position = aVertexPosition;\n      vTextureCoord1 = (uUvTransform * vec4(aTextureCoord - offset1, 0, 1)).xy;\n      vTextureCoord2 = (uUvTransform * vec4(aTextureCoord - offset2, 0, 1)).xy;\n      vTextureCoord3 = (uUvTransform * vec4(aTextureCoord + offset2, 0, 1)).xy;\n      vTextureCoord4 = (uUvTransform * vec4(aTextureCoord + offset1, 0, 1)).xy;\n    }\n`;\n// Fragment shader program\nlet greyscaleFsSource = `\n  varying highp vec2 vTextureCoord1;\n  varying highp vec2 vTextureCoord2;\n  varying highp vec2 vTextureCoord3;\n  varying highp vec2 vTextureCoord4;\n\n  uniform sampler2D uSampler;\n\n  const lowp vec3 colorWeights = vec3(77.0 / 256.0, 150.0 / 256.0, 29.0 / 256.0);\n\n  void main(void) {\n    lowp vec4 outpx;\n\n    outpx.r = dot(colorWeights, texture2D(uSampler, vTextureCoord1).xyz);\n    outpx.g = dot(colorWeights, texture2D(uSampler, vTextureCoord2).xyz);\n    outpx.b = dot(colorWeights, texture2D(uSampler, vTextureCoord3).xyz);\n    outpx.a = dot(colorWeights, texture2D(uSampler, vTextureCoord4).xyz);\n\n    gl_FragColor = outpx;\n  }\n`;\n"]},"metadata":{},"sourceType":"script"}