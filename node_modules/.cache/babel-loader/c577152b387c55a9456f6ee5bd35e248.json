{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Camera = exports.CameraMirrorMode = exports.CameraPoseMode = void 0;\n\nconst Zappar = require(\"@zappar/zappar\");\n\nconst three_1 = require(\"./three\");\n\nconst defaultpipeline_1 = require(\"./defaultpipeline\");\n\nconst cameraTexture_1 = require(\"./cameraTexture\");\n/**\n * The pose modes that determine how the camera moves around in the scene.\n */\n\n\nvar CameraPoseMode;\n\n(function (CameraPoseMode) {\n  /**\n   * The camera sits, stationary, at the origin of world space, and points down the negative Z axis.\n   * In this mode, tracked anchors move in world space as the user moves the device or tracked objects in the real world.\n   */\n  CameraPoseMode[CameraPoseMode[\"Default\"] = 0] = \"Default\";\n  /**\n   * The camera sits at the origin of world space, but rotates as the user rotates the physical device.\n   *\n   * When the Zappar library initializes, the negative Z axis of world space points forward in front of the user.\n   *\n   * In this mode, tracked anchors move in world space as the user moves the device or tracked objects in the real world.\n   */\n\n  CameraPoseMode[CameraPoseMode[\"Attitude\"] = 1] = \"Attitude\";\n  /**\n   * In this case the camera moves and rotates in world space around the anchor at the origin.\n   */\n\n  CameraPoseMode[CameraPoseMode[\"AnchorOrigin\"] = 2] = \"AnchorOrigin\";\n})(CameraPoseMode = exports.CameraPoseMode || (exports.CameraPoseMode = {}));\n/**\n * The mirror modes that may be used.\n */\n\n\nvar CameraMirrorMode;\n\n(function (CameraMirrorMode) {\n  /**\n   * No mirroring.\n   */\n  CameraMirrorMode[CameraMirrorMode[\"None\"] = 0] = \"None\";\n  /**\n   * This mode mirrors the background camera texture and ensures content still appears correctly tracked.\n   * In this mode your content itself isn't flipped, so any text in your tracked content doesn't appear mirrored.\n   * This is the default mode for the user-facing camera.\n   */\n\n  CameraMirrorMode[CameraMirrorMode[\"Poses\"] = 1] = \"Poses\";\n  /**\n   * In this mode, the Zappar camera applies a scaleX(-1) CSS transform to your whole canvas.\n   * This way both the camera and your content appear mirrored.\n   */\n\n  CameraMirrorMode[CameraMirrorMode[\"CSS\"] = 2] = \"CSS\";\n})(CameraMirrorMode = exports.CameraMirrorMode || (exports.CameraMirrorMode = {}));\n/**\n * The directions that the camera can face.\n */\n\n\nvar CameraDirection;\n\n(function (CameraDirection) {\n  /** The camera is not running.\n   * This is the default mode for the camera.\n   */\n  CameraDirection[CameraDirection[\"None\"] = 0] = \"None\";\n  /** In this mode, the camera is always facing the user. */\n\n  CameraDirection[CameraDirection[\"User\"] = 1] = \"User\";\n  /** In this mode, the camera is always facing away from the user. */\n\n  CameraDirection[CameraDirection[\"Rear\"] = 2] = \"Rear\";\n})(CameraDirection || (CameraDirection = {}));\n/**\n * Creates a camera that you can use instead of a perspective camera.\n *\n * The camera provides a {@link Camera.backgroundTexture} property containing the camera feed.\n *\n * The ZapparThree library needs to use your WebGL context in order to process camera frames.\n * You can set it when your page loads using {@link glContextSet}.\n * @see https://docs.zap.works/universal-ar/web-libraries/threejs/camera-setup/\n */\n\n\nclass Camera extends three_1.THREE.Camera {\n  /**\n   * Constructs a new Camera.\n   * @param pipeline - The pipeline that this tracker will operate within.\n   * @property pipeline - The pipeline that this tracker will operate within.\n   * @property zNear - The near clipping plane.\n   * @property zFar - The far clipping plane.\n   * @property rearCameraSource? - The camera source which will be used for the rear camera.\n   * @property userCameraSource? - The camera source which will be used for the user camera.\n   */\n  constructor(opts) {\n    super();\n    /**\n     * The pose mode that determines how the camera moves in the scene.\n     */\n\n    this.poseMode = CameraPoseMode.Default;\n    /**\n     * The mirror mode that is used for the rear camera.\n     */\n\n    this.rearCameraMirrorMode = CameraMirrorMode.None;\n    /**\n     * The mirror mode that is used for the user camera.\n     */\n\n    this.userCameraMirrorMode = CameraMirrorMode.Poses;\n    this._currentMirrorMode = CameraMirrorMode.None;\n    /**\n     * @ignore\n     * Needed for raycasters to work.\n     */\n\n    this.isPerspectiveCamera = true;\n    this.cameraDirection = CameraDirection.None;\n    this.hasSetCSSScaleX = false;\n    this.renderWidth = 0;\n    this.renderHeight = 0;\n    this.pipeline = opts instanceof Zappar.Pipeline ? opts : (opts === null || opts === void 0 ? void 0 : opts.pipeline) || (0, defaultpipeline_1.getDefaultPipeline)();\n    this.rawPose = this.pipeline.cameraPoseDefault();\n\n    if (opts && !(opts instanceof Zappar.Pipeline)) {\n      this.zNear = opts.zNear ? opts.zNear : 0.1;\n      this.zFar = opts.zFar ? opts.zFar : 100;\n      this.rearCameraSource = this.cameraSourceFromOpts(opts.rearCameraSource);\n      this.userCameraSource = this.cameraSourceFromOpts(opts.userCameraSource, true);\n      this.backgroundTexture = opts.backgroundTexture ? opts.backgroundTexture : new cameraTexture_1.CameraTexture();\n    } else {\n      this.rearCameraSource = new defaultpipeline_1.CameraSource(Zappar.cameraDefaultDeviceID(), this.pipeline);\n      this.userCameraSource = new defaultpipeline_1.CameraSource(Zappar.cameraDefaultDeviceID(true), this.pipeline);\n      this.backgroundTexture = new cameraTexture_1.CameraTexture();\n    }\n\n    this.matrixAutoUpdate = false;\n    document.addEventListener(\"visibilitychange\", () => {\n      document.visibilityState === \"visible\" ? this.resume() : this.pause();\n    });\n  }\n  /**\n   * Constructs a new CameraSource or HTMLElementSource based on parameters passed in.\n   * @param cameraSource - HTML element or camera device ID which will be used as a source\n   * @returns CameraSource if cameraSource param is undefined or string, otherwise HTMLElementSource.\n   */\n\n\n  cameraSourceFromOpts(cameraSource) {\n    let frontFacing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return cameraSource instanceof Element ? new Zappar.HTMLElementSource(this.pipeline, cameraSource) : new defaultpipeline_1.CameraSource(cameraSource || Zappar.cameraDefaultDeviceID(frontFacing), this.pipeline);\n  }\n  /**\n   * Pauses the camera source.\n   */\n\n\n  pause() {\n    this.userCameraSource.pause();\n    this.rearCameraSource.pause();\n  }\n  /**\n   * Starts the camera source.\n   *\n   * Starting a given source pauses any other sources within the same pipeline.\n   */\n\n\n  resume() {\n    switch (this.cameraDirection) {\n      case CameraDirection.User:\n        this.userCameraSource.start();\n        break;\n\n      case CameraDirection.Rear:\n        this.rearCameraSource.start();\n        break;\n\n      default:\n        // do not start any camera\n        break;\n    }\n  }\n  /**\n   * Starts the camera source.\n   * @param userFacing - If true, starts the user facing camera. (i.e selfie).\n   */\n\n\n  start(userFacing) {\n    this.cameraDirection = userFacing ? CameraDirection.User : CameraDirection.Rear;\n    this.resume();\n  }\n  /**\n   * Stops the camera source.\n   */\n\n\n  stop() {\n    this.cameraDirection = CameraDirection.None;\n    this.pause();\n  }\n  /**\n   * Sets the pose mode to 'Anchor Origin'.\n   *\n   * In this case the camera moves and rotates in world space around the anchor at the origin.\n   * @param anchor - The anchor that defines the origin.\n   */\n\n\n  setPoseModeAnchorOrigin(anchor) {\n    this.poseAnchorOrigin = anchor;\n    this.poseMode = CameraPoseMode.AnchorOrigin;\n  }\n  /**\n   * Gets the current mirror mode.\n   */\n\n\n  get currentMirrorMode() {\n    // eslint-disable-next-line no-underscore-dangle\n    return this._currentMirrorMode;\n  }\n  /**\n   * Processes camera frames and updates `backgroundTexture`.\n   * Call this function on your pipeline once an animation frame (e.g. during your `requestAnimationFrame` function).\n   * @param renderer - The Three.js WebGL renderer.\n   */\n\n\n  updateFrame(renderer) {\n    // ThreeJS manages its GL state for optimal performance\n    // Reset it here so it's predictable for processGL\n    renderer.state.reset();\n    this.pipeline.processGL(); // Return to ThreeJS's standard state since processGL will have altered some state\n\n    renderer.state.reset(); // Update to using the latest tracking frame data\n\n    this.pipeline.frameUpdate(); // eslint-disable-next-line no-underscore-dangle\n\n    this._currentMirrorMode = this.pipeline.cameraFrameUserFacing() ? this.userCameraMirrorMode : this.rearCameraMirrorMode;\n    const {\n      domElement\n    } = renderer;\n\n    if (this.currentMirrorMode !== CameraMirrorMode.CSS && this.hasSetCSSScaleX) {\n      domElement.style.transform = \"\";\n      this.hasSetCSSScaleX = false;\n    } else if (this.currentMirrorMode === CameraMirrorMode.CSS && !this.hasSetCSSScaleX) {\n      domElement.style.transform = \"scaleX(-1)\";\n      this.hasSetCSSScaleX = true;\n    }\n\n    this.renderWidth = renderer.domElement.width;\n    this.renderHeight = renderer.domElement.height; // eslint-disable-next-line no-underscore-dangle\n\n    this._updateProjectionMatrix(); // Get the pose of the camera from the Zappar library\n\n\n    switch (this.poseMode) {\n      case CameraPoseMode.Default:\n        this.rawPose = this.pipeline.cameraPoseDefault();\n        break;\n\n      case CameraPoseMode.Attitude:\n        this.rawPose = this.pipeline.cameraPoseWithAttitude(this.currentMirrorMode === CameraMirrorMode.Poses);\n        break;\n\n      case CameraPoseMode.AnchorOrigin:\n        this.rawPose = this.poseAnchorOrigin ? this.getOriginPose() : this.pipeline.cameraPoseDefault();\n        break;\n\n      default:\n        this.rawPose = this.pipeline.cameraPoseDefault();\n        break;\n    }\n\n    this.backgroundTexture.MirrorMode = this.currentMirrorMode;\n    this.backgroundTexture.updateFromPipeline(renderer, this.pipeline);\n  } // eslint-disable-next-line no-underscore-dangle\n\n\n  _updateProjectionMatrix() {\n    // Get the projection matrix for the camera from the Zappar library\n    const model = this.pipeline.cameraModel();\n    const projection = Zappar.projectionMatrixFromCameraModel(model, this.renderWidth, this.renderHeight, this.zNear, this.zFar);\n    this.projectionMatrix.fromArray(projection);\n\n    if (typeof this.projectionMatrixInverse.invert === \"function\") {\n      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n    } else {\n      this.projectionMatrixInverse.getInverse(this.projectionMatrix);\n    }\n  }\n\n  updateMatrixWorld(force) {\n    this.matrix.fromArray(this.rawPose);\n    this.matrix.decompose(this.position, this.quaternion, this.scale);\n    super.updateMatrixWorld(force);\n  }\n\n  getOriginPose() {\n    if (!this.poseAnchorOrigin) return this.pipeline.cameraPoseDefault();\n    return this.pipeline.cameraPoseWithOrigin(this.poseAnchorOrigin.poseCameraRelative(this.currentMirrorMode === CameraMirrorMode.Poses));\n  }\n  /**\n   * Destroys the camera sources.\n   */\n\n\n  dispose() {\n    this.rearCameraSource.destroy();\n    this.userCameraSource.destroy();\n  }\n\n}\n\nexports.Camera = Camera;","map":{"version":3,"sources":["/Users/StanleyWalker/Desktop/react-three-example-face-tracking-helmet-1/node_modules/@zappar/zappar-threejs/lib/camera.js"],"names":["Object","defineProperty","exports","value","Camera","CameraMirrorMode","CameraPoseMode","Zappar","require","three_1","defaultpipeline_1","cameraTexture_1","CameraDirection","THREE","constructor","opts","poseMode","Default","rearCameraMirrorMode","None","userCameraMirrorMode","Poses","_currentMirrorMode","isPerspectiveCamera","cameraDirection","hasSetCSSScaleX","renderWidth","renderHeight","pipeline","Pipeline","getDefaultPipeline","rawPose","cameraPoseDefault","zNear","zFar","rearCameraSource","cameraSourceFromOpts","userCameraSource","backgroundTexture","CameraTexture","CameraSource","cameraDefaultDeviceID","matrixAutoUpdate","document","addEventListener","visibilityState","resume","pause","cameraSource","frontFacing","Element","HTMLElementSource","User","start","Rear","userFacing","stop","setPoseModeAnchorOrigin","anchor","poseAnchorOrigin","AnchorOrigin","currentMirrorMode","updateFrame","renderer","state","reset","processGL","frameUpdate","cameraFrameUserFacing","domElement","CSS","style","transform","width","height","_updateProjectionMatrix","Attitude","cameraPoseWithAttitude","getOriginPose","MirrorMode","updateFromPipeline","model","cameraModel","projection","projectionMatrixFromCameraModel","projectionMatrix","fromArray","projectionMatrixInverse","invert","copy","getInverse","updateMatrixWorld","force","matrix","decompose","position","quaternion","scale","cameraPoseWithOrigin","poseCameraRelative","dispose","destroy"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Camera = exports.CameraMirrorMode = exports.CameraPoseMode = void 0;\nconst Zappar = require(\"@zappar/zappar\");\nconst three_1 = require(\"./three\");\nconst defaultpipeline_1 = require(\"./defaultpipeline\");\nconst cameraTexture_1 = require(\"./cameraTexture\");\n/**\n * The pose modes that determine how the camera moves around in the scene.\n */\nvar CameraPoseMode;\n(function (CameraPoseMode) {\n    /**\n     * The camera sits, stationary, at the origin of world space, and points down the negative Z axis.\n     * In this mode, tracked anchors move in world space as the user moves the device or tracked objects in the real world.\n     */\n    CameraPoseMode[CameraPoseMode[\"Default\"] = 0] = \"Default\";\n    /**\n     * The camera sits at the origin of world space, but rotates as the user rotates the physical device.\n     *\n     * When the Zappar library initializes, the negative Z axis of world space points forward in front of the user.\n     *\n     * In this mode, tracked anchors move in world space as the user moves the device or tracked objects in the real world.\n     */\n    CameraPoseMode[CameraPoseMode[\"Attitude\"] = 1] = \"Attitude\";\n    /**\n     * In this case the camera moves and rotates in world space around the anchor at the origin.\n     */\n    CameraPoseMode[CameraPoseMode[\"AnchorOrigin\"] = 2] = \"AnchorOrigin\";\n})(CameraPoseMode = exports.CameraPoseMode || (exports.CameraPoseMode = {}));\n/**\n * The mirror modes that may be used.\n */\nvar CameraMirrorMode;\n(function (CameraMirrorMode) {\n    /**\n     * No mirroring.\n     */\n    CameraMirrorMode[CameraMirrorMode[\"None\"] = 0] = \"None\";\n    /**\n     * This mode mirrors the background camera texture and ensures content still appears correctly tracked.\n     * In this mode your content itself isn't flipped, so any text in your tracked content doesn't appear mirrored.\n     * This is the default mode for the user-facing camera.\n     */\n    CameraMirrorMode[CameraMirrorMode[\"Poses\"] = 1] = \"Poses\";\n    /**\n     * In this mode, the Zappar camera applies a scaleX(-1) CSS transform to your whole canvas.\n     * This way both the camera and your content appear mirrored.\n     */\n    CameraMirrorMode[CameraMirrorMode[\"CSS\"] = 2] = \"CSS\";\n})(CameraMirrorMode = exports.CameraMirrorMode || (exports.CameraMirrorMode = {}));\n/**\n * The directions that the camera can face.\n */\nvar CameraDirection;\n(function (CameraDirection) {\n    /** The camera is not running.\n     * This is the default mode for the camera.\n     */\n    CameraDirection[CameraDirection[\"None\"] = 0] = \"None\";\n    /** In this mode, the camera is always facing the user. */\n    CameraDirection[CameraDirection[\"User\"] = 1] = \"User\";\n    /** In this mode, the camera is always facing away from the user. */\n    CameraDirection[CameraDirection[\"Rear\"] = 2] = \"Rear\";\n})(CameraDirection || (CameraDirection = {}));\n/**\n * Creates a camera that you can use instead of a perspective camera.\n *\n * The camera provides a {@link Camera.backgroundTexture} property containing the camera feed.\n *\n * The ZapparThree library needs to use your WebGL context in order to process camera frames.\n * You can set it when your page loads using {@link glContextSet}.\n * @see https://docs.zap.works/universal-ar/web-libraries/threejs/camera-setup/\n */\nclass Camera extends three_1.THREE.Camera {\n    /**\n     * Constructs a new Camera.\n     * @param pipeline - The pipeline that this tracker will operate within.\n     * @property pipeline - The pipeline that this tracker will operate within.\n     * @property zNear - The near clipping plane.\n     * @property zFar - The far clipping plane.\n     * @property rearCameraSource? - The camera source which will be used for the rear camera.\n     * @property userCameraSource? - The camera source which will be used for the user camera.\n     */\n    constructor(opts) {\n        super();\n        /**\n         * The pose mode that determines how the camera moves in the scene.\n         */\n        this.poseMode = CameraPoseMode.Default;\n        /**\n         * The mirror mode that is used for the rear camera.\n         */\n        this.rearCameraMirrorMode = CameraMirrorMode.None;\n        /**\n         * The mirror mode that is used for the user camera.\n         */\n        this.userCameraMirrorMode = CameraMirrorMode.Poses;\n        this._currentMirrorMode = CameraMirrorMode.None;\n        /**\n         * @ignore\n         * Needed for raycasters to work.\n         */\n        this.isPerspectiveCamera = true;\n        this.cameraDirection = CameraDirection.None;\n        this.hasSetCSSScaleX = false;\n        this.renderWidth = 0;\n        this.renderHeight = 0;\n        this.pipeline = opts instanceof Zappar.Pipeline ? opts : (opts === null || opts === void 0 ? void 0 : opts.pipeline) || (0, defaultpipeline_1.getDefaultPipeline)();\n        this.rawPose = this.pipeline.cameraPoseDefault();\n        if (opts && !(opts instanceof Zappar.Pipeline)) {\n            this.zNear = opts.zNear ? opts.zNear : 0.1;\n            this.zFar = opts.zFar ? opts.zFar : 100;\n            this.rearCameraSource = this.cameraSourceFromOpts(opts.rearCameraSource);\n            this.userCameraSource = this.cameraSourceFromOpts(opts.userCameraSource, true);\n            this.backgroundTexture = opts.backgroundTexture ? opts.backgroundTexture : new cameraTexture_1.CameraTexture();\n        }\n        else {\n            this.rearCameraSource = new defaultpipeline_1.CameraSource(Zappar.cameraDefaultDeviceID(), this.pipeline);\n            this.userCameraSource = new defaultpipeline_1.CameraSource(Zappar.cameraDefaultDeviceID(true), this.pipeline);\n            this.backgroundTexture = new cameraTexture_1.CameraTexture();\n        }\n        this.matrixAutoUpdate = false;\n        document.addEventListener(\"visibilitychange\", () => {\n            document.visibilityState === \"visible\" ? this.resume() : this.pause();\n        });\n    }\n    /**\n     * Constructs a new CameraSource or HTMLElementSource based on parameters passed in.\n     * @param cameraSource - HTML element or camera device ID which will be used as a source\n     * @returns CameraSource if cameraSource param is undefined or string, otherwise HTMLElementSource.\n     */\n    cameraSourceFromOpts(cameraSource, frontFacing = false) {\n        return cameraSource instanceof Element\n            ? new Zappar.HTMLElementSource(this.pipeline, cameraSource)\n            : new defaultpipeline_1.CameraSource(cameraSource || Zappar.cameraDefaultDeviceID(frontFacing), this.pipeline);\n    }\n    /**\n     * Pauses the camera source.\n     */\n    pause() {\n        this.userCameraSource.pause();\n        this.rearCameraSource.pause();\n    }\n    /**\n     * Starts the camera source.\n     *\n     * Starting a given source pauses any other sources within the same pipeline.\n     */\n    resume() {\n        switch (this.cameraDirection) {\n            case CameraDirection.User:\n                this.userCameraSource.start();\n                break;\n            case CameraDirection.Rear:\n                this.rearCameraSource.start();\n                break;\n            default:\n                // do not start any camera\n                break;\n        }\n    }\n    /**\n     * Starts the camera source.\n     * @param userFacing - If true, starts the user facing camera. (i.e selfie).\n     */\n    start(userFacing) {\n        this.cameraDirection = userFacing ? CameraDirection.User : CameraDirection.Rear;\n        this.resume();\n    }\n    /**\n     * Stops the camera source.\n     */\n    stop() {\n        this.cameraDirection = CameraDirection.None;\n        this.pause();\n    }\n    /**\n     * Sets the pose mode to 'Anchor Origin'.\n     *\n     * In this case the camera moves and rotates in world space around the anchor at the origin.\n     * @param anchor - The anchor that defines the origin.\n     */\n    setPoseModeAnchorOrigin(anchor) {\n        this.poseAnchorOrigin = anchor;\n        this.poseMode = CameraPoseMode.AnchorOrigin;\n    }\n    /**\n     * Gets the current mirror mode.\n     */\n    get currentMirrorMode() {\n        // eslint-disable-next-line no-underscore-dangle\n        return this._currentMirrorMode;\n    }\n    /**\n     * Processes camera frames and updates `backgroundTexture`.\n     * Call this function on your pipeline once an animation frame (e.g. during your `requestAnimationFrame` function).\n     * @param renderer - The Three.js WebGL renderer.\n     */\n    updateFrame(renderer) {\n        // ThreeJS manages its GL state for optimal performance\n        // Reset it here so it's predictable for processGL\n        renderer.state.reset();\n        this.pipeline.processGL();\n        // Return to ThreeJS's standard state since processGL will have altered some state\n        renderer.state.reset();\n        // Update to using the latest tracking frame data\n        this.pipeline.frameUpdate();\n        // eslint-disable-next-line no-underscore-dangle\n        this._currentMirrorMode = this.pipeline.cameraFrameUserFacing() ? this.userCameraMirrorMode : this.rearCameraMirrorMode;\n        const { domElement } = renderer;\n        if (this.currentMirrorMode !== CameraMirrorMode.CSS && this.hasSetCSSScaleX) {\n            domElement.style.transform = \"\";\n            this.hasSetCSSScaleX = false;\n        }\n        else if (this.currentMirrorMode === CameraMirrorMode.CSS && !this.hasSetCSSScaleX) {\n            domElement.style.transform = \"scaleX(-1)\";\n            this.hasSetCSSScaleX = true;\n        }\n        this.renderWidth = renderer.domElement.width;\n        this.renderHeight = renderer.domElement.height;\n        // eslint-disable-next-line no-underscore-dangle\n        this._updateProjectionMatrix();\n        // Get the pose of the camera from the Zappar library\n        switch (this.poseMode) {\n            case CameraPoseMode.Default:\n                this.rawPose = this.pipeline.cameraPoseDefault();\n                break;\n            case CameraPoseMode.Attitude:\n                this.rawPose = this.pipeline.cameraPoseWithAttitude(this.currentMirrorMode === CameraMirrorMode.Poses);\n                break;\n            case CameraPoseMode.AnchorOrigin:\n                this.rawPose = this.poseAnchorOrigin ? this.getOriginPose() : this.pipeline.cameraPoseDefault();\n                break;\n            default:\n                this.rawPose = this.pipeline.cameraPoseDefault();\n                break;\n        }\n        this.backgroundTexture.MirrorMode = this.currentMirrorMode;\n        this.backgroundTexture.updateFromPipeline(renderer, this.pipeline);\n    }\n    // eslint-disable-next-line no-underscore-dangle\n    _updateProjectionMatrix() {\n        // Get the projection matrix for the camera from the Zappar library\n        const model = this.pipeline.cameraModel();\n        const projection = Zappar.projectionMatrixFromCameraModel(model, this.renderWidth, this.renderHeight, this.zNear, this.zFar);\n        this.projectionMatrix.fromArray(projection);\n        if (typeof this.projectionMatrixInverse.invert === \"function\") {\n            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n        }\n        else {\n            this.projectionMatrixInverse.getInverse(this.projectionMatrix);\n        }\n    }\n    updateMatrixWorld(force) {\n        this.matrix.fromArray(this.rawPose);\n        this.matrix.decompose(this.position, this.quaternion, this.scale);\n        super.updateMatrixWorld(force);\n    }\n    getOriginPose() {\n        if (!this.poseAnchorOrigin)\n            return this.pipeline.cameraPoseDefault();\n        return this.pipeline.cameraPoseWithOrigin(this.poseAnchorOrigin.poseCameraRelative(this.currentMirrorMode === CameraMirrorMode.Poses));\n    }\n    /**\n     * Destroys the camera sources.\n     */\n    dispose() {\n        this.rearCameraSource.destroy();\n        this.userCameraSource.destroy();\n    }\n}\nexports.Camera = Camera;\n"]},"metadata":{},"sourceType":"script"}