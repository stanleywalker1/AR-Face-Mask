{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CameraEnvironmentMap = void 0;\n\nconst three_1 = require(\"./three\");\n\nclass CameraEnvironmentMap {\n  /**\n   * Constructs a new Camera Environment Map.\n   */\n  constructor() {\n    this.cubeMapScene = new three_1.THREE.Scene();\n    this.renderTarget = new three_1.THREE.WebGLCubeRenderTarget(256, {\n      format: three_1.THREE.RGBAFormat,\n      generateMipmaps: true,\n      minFilter: three_1.THREE.LinearMipmapLinearFilter\n    });\n    this.cubeCamera = new three_1.THREE.CubeCamera(0.1, 1000, this.renderTarget);\n    this.sphereMaterial = new three_1.THREE.MeshBasicMaterial({\n      side: three_1.THREE.DoubleSide\n    });\n    this.sphereGroup = new three_1.THREE.Group();\n    /**\n     * The resulting map texture. Set this as your `scene.environment` or as a material's `envMap`.\n     */\n\n    this.environmentMap = this.renderTarget.texture;\n    this.cubeMapScene.add(this.cubeCamera);\n    const sphere = new three_1.THREE.Mesh(new three_1.THREE.SphereBufferGeometry(10, 16, 12), this.sphereMaterial);\n    sphere.rotation.set(0, -0.5 * Math.PI, 0);\n    this.sphereGroup.add(sphere);\n    this.cubeMapScene.add(this.sphereGroup);\n  }\n  /**\n   * Destroy the resources held by this object.\n   */\n\n\n  dispose() {\n    this.renderTarget.dispose();\n    this.sphereMaterial.dispose();\n  }\n  /**\n   * Update the contents of the environment map with the latest texture from the camera.\n   *\n   * Call this each frame after you call `update` on your Zappar camera, but before you render the scene.\n   * @param renderer - Your renderer object\n   * @param zapparCamera - The Zappar camera you're using to render your scene\n   */\n\n\n  update(renderer, zapparCamera) {\n    this.environmentMap.encoding = renderer.outputEncoding;\n    this.sphereMaterial.map = zapparCamera.backgroundTexture;\n    this.sphereGroup.quaternion.copy(zapparCamera.quaternion);\n    this.cubeCamera.update(renderer, this.cubeMapScene);\n  }\n\n}\n\nexports.CameraEnvironmentMap = CameraEnvironmentMap;","map":{"version":3,"sources":["/Users/StanleyWalker/Desktop/face-mask-demo/AR-Face-Mask/node_modules/@zappar/zappar-threejs/lib/cameraenvironmentmap.js"],"names":["Object","defineProperty","exports","value","CameraEnvironmentMap","three_1","require","constructor","cubeMapScene","THREE","Scene","renderTarget","WebGLCubeRenderTarget","format","RGBAFormat","generateMipmaps","minFilter","LinearMipmapLinearFilter","cubeCamera","CubeCamera","sphereMaterial","MeshBasicMaterial","side","DoubleSide","sphereGroup","Group","environmentMap","texture","add","sphere","Mesh","SphereBufferGeometry","rotation","set","Math","PI","dispose","update","renderer","zapparCamera","encoding","outputEncoding","map","backgroundTexture","quaternion","copy"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,oBAAR,GAA+B,KAAK,CAApC;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,MAAMF,oBAAN,CAA2B;AACvB;AACJ;AACA;AACIG,EAAAA,WAAW,GAAG;AACV,SAAKC,YAAL,GAAoB,IAAIH,OAAO,CAACI,KAAR,CAAcC,KAAlB,EAApB;AACA,SAAKC,YAAL,GAAoB,IAAIN,OAAO,CAACI,KAAR,CAAcG,qBAAlB,CAAwC,GAAxC,EAA6C;AAC7DC,MAAAA,MAAM,EAAER,OAAO,CAACI,KAAR,CAAcK,UADuC;AAE7DC,MAAAA,eAAe,EAAE,IAF4C;AAG7DC,MAAAA,SAAS,EAAEX,OAAO,CAACI,KAAR,CAAcQ;AAHoC,KAA7C,CAApB;AAKA,SAAKC,UAAL,GAAkB,IAAIb,OAAO,CAACI,KAAR,CAAcU,UAAlB,CAA6B,GAA7B,EAAkC,IAAlC,EAAwC,KAAKR,YAA7C,CAAlB;AACA,SAAKS,cAAL,GAAsB,IAAIf,OAAO,CAACI,KAAR,CAAcY,iBAAlB,CAAoC;AAAEC,MAAAA,IAAI,EAAEjB,OAAO,CAACI,KAAR,CAAcc;AAAtB,KAApC,CAAtB;AACA,SAAKC,WAAL,GAAmB,IAAInB,OAAO,CAACI,KAAR,CAAcgB,KAAlB,EAAnB;AACA;AACR;AACA;;AACQ,SAAKC,cAAL,GAAsB,KAAKf,YAAL,CAAkBgB,OAAxC;AACA,SAAKnB,YAAL,CAAkBoB,GAAlB,CAAsB,KAAKV,UAA3B;AACA,UAAMW,MAAM,GAAG,IAAIxB,OAAO,CAACI,KAAR,CAAcqB,IAAlB,CAAuB,IAAIzB,OAAO,CAACI,KAAR,CAAcsB,oBAAlB,CAAuC,EAAvC,EAA2C,EAA3C,EAA+C,EAA/C,CAAvB,EAA2E,KAAKX,cAAhF,CAAf;AACAS,IAAAA,MAAM,CAACG,QAAP,CAAgBC,GAAhB,CAAoB,CAApB,EAAuB,CAAC,GAAD,GAAOC,IAAI,CAACC,EAAnC,EAAuC,CAAvC;AACA,SAAKX,WAAL,CAAiBI,GAAjB,CAAqBC,MAArB;AACA,SAAKrB,YAAL,CAAkBoB,GAAlB,CAAsB,KAAKJ,WAA3B;AACH;AACD;AACJ;AACA;;;AACIY,EAAAA,OAAO,GAAG;AACN,SAAKzB,YAAL,CAAkByB,OAAlB;AACA,SAAKhB,cAAL,CAAoBgB,OAApB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,MAAM,CAACC,QAAD,EAAWC,YAAX,EAAyB;AAC3B,SAAKb,cAAL,CAAoBc,QAApB,GAA+BF,QAAQ,CAACG,cAAxC;AACA,SAAKrB,cAAL,CAAoBsB,GAApB,GAA0BH,YAAY,CAACI,iBAAvC;AACA,SAAKnB,WAAL,CAAiBoB,UAAjB,CAA4BC,IAA5B,CAAiCN,YAAY,CAACK,UAA9C;AACA,SAAK1B,UAAL,CAAgBmB,MAAhB,CAAuBC,QAAvB,EAAiC,KAAK9B,YAAtC;AACH;;AA3CsB;;AA6C3BN,OAAO,CAACE,oBAAR,GAA+BA,oBAA/B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CameraEnvironmentMap = void 0;\nconst three_1 = require(\"./three\");\nclass CameraEnvironmentMap {\n    /**\n     * Constructs a new Camera Environment Map.\n     */\n    constructor() {\n        this.cubeMapScene = new three_1.THREE.Scene();\n        this.renderTarget = new three_1.THREE.WebGLCubeRenderTarget(256, {\n            format: three_1.THREE.RGBAFormat,\n            generateMipmaps: true,\n            minFilter: three_1.THREE.LinearMipmapLinearFilter,\n        });\n        this.cubeCamera = new three_1.THREE.CubeCamera(0.1, 1000, this.renderTarget);\n        this.sphereMaterial = new three_1.THREE.MeshBasicMaterial({ side: three_1.THREE.DoubleSide });\n        this.sphereGroup = new three_1.THREE.Group();\n        /**\n         * The resulting map texture. Set this as your `scene.environment` or as a material's `envMap`.\n         */\n        this.environmentMap = this.renderTarget.texture;\n        this.cubeMapScene.add(this.cubeCamera);\n        const sphere = new three_1.THREE.Mesh(new three_1.THREE.SphereBufferGeometry(10, 16, 12), this.sphereMaterial);\n        sphere.rotation.set(0, -0.5 * Math.PI, 0);\n        this.sphereGroup.add(sphere);\n        this.cubeMapScene.add(this.sphereGroup);\n    }\n    /**\n     * Destroy the resources held by this object.\n     */\n    dispose() {\n        this.renderTarget.dispose();\n        this.sphereMaterial.dispose();\n    }\n    /**\n     * Update the contents of the environment map with the latest texture from the camera.\n     *\n     * Call this each frame after you call `update` on your Zappar camera, but before you render the scene.\n     * @param renderer - Your renderer object\n     * @param zapparCamera - The Zappar camera you're using to render your scene\n     */\n    update(renderer, zapparCamera) {\n        this.environmentMap.encoding = renderer.outputEncoding;\n        this.sphereMaterial.map = zapparCamera.backgroundTexture;\n        this.sphereGroup.quaternion.copy(zapparCamera.quaternion);\n        this.cubeCamera.update(renderer, this.cubeMapScene);\n    }\n}\nexports.CameraEnvironmentMap = CameraEnvironmentMap;\n"]},"metadata":{},"sourceType":"script"}