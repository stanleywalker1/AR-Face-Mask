{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ImageTracker = void 0;\n\nconst event_1 = require(\"./event\");\n\nconst zappar_1 = require(\"./zappar\");\n/**\n * Attaches content to a known image as it moves around in the camera view.\n * @see https://docs.zap.works/universal-ar/javascript/image-tracking/\n */\n\n\nclass ImageTracker {\n  /**\n   * Constructs a new ImageTracker\n   * @param _pipeline - The pipeline that this tracker will operate within.\n   * @param targetFile - The .zpt target file from the source image you'd like to track.\n   * @see https://docs.zap.works/universal-ar/zapworks-cli/\n  */\n  constructor(_pipeline, targetFile) {\n    this._pipeline = _pipeline;\n    /**\n    * Emitted when an anchor becomes visible in a camera frame.\n    */\n\n    this.onVisible = new event_1.Event1();\n    /**\n    * Emitted when an anchor goes from being visible in the previous camera frame, to not being visible in the current frame.\n    */\n\n    this.onNotVisible = new event_1.Event1();\n    /**\n    * Emitted when a new anchor is created by the tracker.\n    */\n\n    this.onNewAnchor = new event_1.Event1();\n    /**\n    * The set of currently visible anchors.\n    */\n\n    this.visible = new Set();\n    /**\n    * A map of the available image anchors by their respective IDs.\n    */\n\n    this.anchors = new Map();\n    this._visibleLastFrame = new Set();\n\n    this._frameUpdate = () => {\n      const newAnchors = new Set(); // Swap the visible and visibleLastFrame so we can avoid a set allocation\n\n      const swap = this.visible;\n      this.visible = this._visibleLastFrame;\n      this._visibleLastFrame = swap;\n      this.visible.clear();\n\n      const num = this._z.image_tracker_anchor_count(this._impl);\n\n      for (let i = 0; i < num; i++) {\n        const id = this._z.image_tracker_anchor_id(this._impl, i);\n\n        let anchor = this.anchors.get(id);\n        let isNew = false; // TODO: declared but never used?\n\n        if (!anchor) {\n          anchor = {\n            onVisible: new event_1.Event(),\n            onNotVisible: new event_1.Event(),\n            id: id,\n            poseCameraRelative: mirror => this._z.image_tracker_anchor_pose_camera_relative(this._impl, i, mirror === true),\n            pose: (cameraPose, mirror) => this._z.image_tracker_anchor_pose(this._impl, i, cameraPose, mirror === true),\n            visible: true\n          };\n          isNew = true;\n          this.anchors.set(id, anchor);\n          newAnchors.add(anchor);\n        }\n\n        anchor.visible = true;\n        this.visible.add(anchor);\n      } // Events\n\n\n      for (const anchor of newAnchors) this.onNewAnchor.emit(anchor);\n\n      for (const anchor of this.visible) {\n        if (!this._visibleLastFrame.has(anchor)) {\n          this.onVisible.emit(anchor);\n          anchor.onVisible.emit();\n        } else {\n          this._visibleLastFrame.delete(anchor);\n        }\n      }\n\n      for (const anchor of this._visibleLastFrame) {\n        this.onNotVisible.emit(anchor);\n        anchor.onNotVisible.emit();\n      }\n    };\n\n    this._pipeline._onFrameUpdateInternal.bind(this._frameUpdate);\n\n    this._z = zappar_1.z();\n    this._impl = this._z.image_tracker_create(this._pipeline._getImpl());\n    if (targetFile) this.loadTarget(targetFile);\n  }\n  /**\n   * Destroys the image tracker.\n   */\n\n\n  destroy() {\n    this._pipeline._onFrameUpdateInternal.unbind(this._frameUpdate);\n\n    this.anchors.clear();\n    this.visible.clear();\n\n    this._z.image_tracker_destroy(this._impl);\n  }\n  /**\n   * Loads a target file.\n   * @param src - A URL to, or an ArrayBuffer of, the target file from the source image you'd like to track.\n   * @see https://docs.zap.works/universal-ar/zapworks-cli/\n   * @returns A promise that's resolved once the file is downloaded. It may still take a few frames for the tracker to fully initialize and detect images.\n  */\n\n\n  loadTarget(src) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof src === \"string\") {\n        src = yield (yield fetch(src)).arrayBuffer();\n      }\n\n      this._z.image_tracker_target_load_from_memory(this._impl, src);\n    });\n  }\n  /**\n   * Gets/sets the enabled state of the image tracker.\n   * Disable when not in use to save computational resources during frame processing.\n   */\n\n\n  get enabled() {\n    return this._z.image_tracker_enabled(this._impl);\n  }\n\n  set enabled(e) {\n    this._z.image_tracker_enabled_set(this._impl, e);\n  }\n\n}\n\nexports.ImageTracker = ImageTracker;","map":{"version":3,"sources":["/Users/StanleyWalker/Desktop/face-mask-demo/AR-Face-Mask/node_modules/@zappar/zappar/lib/imagetracker.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","ImageTracker","event_1","require","zappar_1","constructor","_pipeline","targetFile","onVisible","Event1","onNotVisible","onNewAnchor","visible","Set","anchors","Map","_visibleLastFrame","_frameUpdate","newAnchors","swap","clear","num","_z","image_tracker_anchor_count","_impl","i","id","image_tracker_anchor_id","anchor","get","isNew","Event","poseCameraRelative","mirror","image_tracker_anchor_pose_camera_relative","pose","cameraPose","image_tracker_anchor_pose","set","add","emit","has","delete","_onFrameUpdateInternal","bind","z","image_tracker_create","_getImpl","loadTarget","destroy","unbind","image_tracker_destroy","src","fetch","arrayBuffer","image_tracker_target_load_from_memory","enabled","image_tracker_enabled","image_tracker_enabled_set"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImageTracker = void 0;\nconst event_1 = require(\"./event\");\nconst zappar_1 = require(\"./zappar\");\n/**\n * Attaches content to a known image as it moves around in the camera view.\n * @see https://docs.zap.works/universal-ar/javascript/image-tracking/\n */\nclass ImageTracker {\n    /**\n     * Constructs a new ImageTracker\n     * @param _pipeline - The pipeline that this tracker will operate within.\n     * @param targetFile - The .zpt target file from the source image you'd like to track.\n     * @see https://docs.zap.works/universal-ar/zapworks-cli/\n    */\n    constructor(_pipeline, targetFile) {\n        this._pipeline = _pipeline;\n        /**\n        * Emitted when an anchor becomes visible in a camera frame.\n        */\n        this.onVisible = new event_1.Event1();\n        /**\n        * Emitted when an anchor goes from being visible in the previous camera frame, to not being visible in the current frame.\n        */\n        this.onNotVisible = new event_1.Event1();\n        /**\n        * Emitted when a new anchor is created by the tracker.\n        */\n        this.onNewAnchor = new event_1.Event1();\n        /**\n        * The set of currently visible anchors.\n        */\n        this.visible = new Set();\n        /**\n        * A map of the available image anchors by their respective IDs.\n        */\n        this.anchors = new Map();\n        this._visibleLastFrame = new Set();\n        this._frameUpdate = () => {\n            const newAnchors = new Set();\n            // Swap the visible and visibleLastFrame so we can avoid a set allocation\n            const swap = this.visible;\n            this.visible = this._visibleLastFrame;\n            this._visibleLastFrame = swap;\n            this.visible.clear();\n            const num = this._z.image_tracker_anchor_count(this._impl);\n            for (let i = 0; i < num; i++) {\n                const id = this._z.image_tracker_anchor_id(this._impl, i);\n                let anchor = this.anchors.get(id);\n                let isNew = false; // TODO: declared but never used?\n                if (!anchor) {\n                    anchor = {\n                        onVisible: new event_1.Event(),\n                        onNotVisible: new event_1.Event(),\n                        id: id,\n                        poseCameraRelative: mirror => this._z.image_tracker_anchor_pose_camera_relative(this._impl, i, mirror === true),\n                        pose: (cameraPose, mirror) => this._z.image_tracker_anchor_pose(this._impl, i, cameraPose, mirror === true),\n                        visible: true\n                    };\n                    isNew = true;\n                    this.anchors.set(id, anchor);\n                    newAnchors.add(anchor);\n                }\n                anchor.visible = true;\n                this.visible.add(anchor);\n            }\n            // Events\n            for (const anchor of newAnchors)\n                this.onNewAnchor.emit(anchor);\n            for (const anchor of this.visible) {\n                if (!this._visibleLastFrame.has(anchor)) {\n                    this.onVisible.emit(anchor);\n                    anchor.onVisible.emit();\n                }\n                else {\n                    this._visibleLastFrame.delete(anchor);\n                }\n            }\n            for (const anchor of this._visibleLastFrame) {\n                this.onNotVisible.emit(anchor);\n                anchor.onNotVisible.emit();\n            }\n        };\n        this._pipeline._onFrameUpdateInternal.bind(this._frameUpdate);\n        this._z = zappar_1.z();\n        this._impl = this._z.image_tracker_create(this._pipeline._getImpl());\n        if (targetFile)\n            this.loadTarget(targetFile);\n    }\n    /**\n     * Destroys the image tracker.\n     */\n    destroy() {\n        this._pipeline._onFrameUpdateInternal.unbind(this._frameUpdate);\n        this.anchors.clear();\n        this.visible.clear();\n        this._z.image_tracker_destroy(this._impl);\n    }\n    /**\n     * Loads a target file.\n     * @param src - A URL to, or an ArrayBuffer of, the target file from the source image you'd like to track.\n     * @see https://docs.zap.works/universal-ar/zapworks-cli/\n     * @returns A promise that's resolved once the file is downloaded. It may still take a few frames for the tracker to fully initialize and detect images.\n    */\n    loadTarget(src) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof src === \"string\") {\n                src = yield (yield fetch(src)).arrayBuffer();\n            }\n            this._z.image_tracker_target_load_from_memory(this._impl, src);\n        });\n    }\n    /**\n     * Gets/sets the enabled state of the image tracker.\n     * Disable when not in use to save computational resources during frame processing.\n     */\n    get enabled() {\n        return this._z.image_tracker_enabled(this._impl);\n    }\n    set enabled(e) {\n        this._z.image_tracker_enabled_set(this._impl, e);\n    }\n}\nexports.ImageTracker = ImageTracker;\n"]},"metadata":{},"sourceType":"script"}