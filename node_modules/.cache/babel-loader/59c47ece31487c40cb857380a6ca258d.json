{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadedPromise = exports.loaded = exports.browserIncompatibleUI = exports.browserIncompatible = exports.drawPlane = exports.projectionMatrixFromCameraModel = exports.invert = exports.cameraDefaultDeviceID = exports.z = void 0;\n\nconst zappar_cv_1 = require(\"@zappar/zappar-cv\");\n\nconst gl_matrix_1 = require(\"gl-matrix\");\n\nconst version_1 = require(\"./version\");\n\nlet _z;\n/**\n * @ignore\n*/\n\n\nfunction z() {\n  if (!_z) {\n    console.log(`Zappar JS v${version_1.VERSION}`);\n    _z = zappar_cv_1.initialize();\n  }\n\n  return _z;\n}\n\nexports.z = z;\n/**\n * Gets the ID or the default rear- or user-facing camera.\n * @param userFacing - Whether 'selfie' camera ID should be returned.\n * @returns The camera device ID.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices\n*/\n\nfunction cameraDefaultDeviceID(userFacing) {\n  return z().camera_default_device_id(userFacing || false);\n}\n\nexports.cameraDefaultDeviceID = cameraDefaultDeviceID;\n/**\n * Inverts a 4x4 Float32Array Matrix.\n * @param m - The 4x4 matrix to be inverted.\n * @returns The inverted Float32Array matrix.\n*/\n\nfunction invert(m) {\n  const ret = gl_matrix_1.mat4.create();\n  gl_matrix_1.mat4.invert(ret, m);\n  return ret;\n}\n\nexports.invert = invert;\n/**\n  * Calculates the projection matrix from a given camera model (i.e. intrinsic camera parameters)\n  * @param model - The camera model.\n  * @param renderWidth - The width of the canvas.\n  * @param renderHeight - The height of the canvas.\n  * @param zNear - The near clipping plane.\n  * @param zFar - The far clipping plane.\n  * @returns A 4x4 column-major projection matrix.\n */\n\nfunction projectionMatrixFromCameraModel(model, renderWidth, renderHeight) {\n  let zNear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.1;\n  let zFar = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 100;\n  return z().projection_matrix_from_camera_model_ext(model, renderWidth, renderHeight, zNear, zFar);\n}\n\nexports.projectionMatrixFromCameraModel = projectionMatrixFromCameraModel;\n/**\n * @ignore\n*/\n\nfunction drawPlane(gl, projectionMatrix, cameraMatrix, targetMatrix, texture) {\n  z().draw_plane(gl, projectionMatrix, cameraMatrix, targetMatrix, texture);\n}\n\nexports.drawPlane = drawPlane;\n/**\n * Detects if your page is running in a browser that's not supported\n * @returns 'true' if the browser is incompatible.\n*/\n\nfunction browserIncompatible() {\n  return z().browser_incompatible();\n}\n\nexports.browserIncompatible = browserIncompatible;\n/**\n * Shows a full-page dialog that informs the user they're using an unsupported browser,\n * and provides a button to 'copy' the current page URL so they can 'paste' it into the\n * address bar of a compatible alternative.\n*/\n\nfunction browserIncompatibleUI() {\n  z().browser_incompatible_ui();\n}\n\nexports.browserIncompatibleUI = browserIncompatibleUI;\n/**\n * Check if the Zappar library is fully loaded and ready to process data.\n * Note that you can still use the full API before this function returns true - it's here to help implement loading screens.\n *\n * @returns 'true' if the library is fully loaded.\n*/\n\nfunction loaded() {\n  return z().loaded();\n}\n\nexports.loaded = loaded;\n/**\n * Gets a promise that resolves when the Zappar library is fully loaded and ready to process data.\n * Note that you can still use the full API before this promise is resolved - it's here to help implement loading screens.\n *\n * @returns a promise that resolves when the library is fully loaded.\n*/\n\nfunction loadedPromise() {\n  return __awaiter(this, void 0, void 0, function* () {\n    while (true) {\n      if (loaded()) return;\n      yield delay(50);\n    }\n  });\n}\n\nexports.loadedPromise = loadedPromise;\n\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}","map":{"version":3,"sources":["/Users/StanleyWalker/Desktop/face-mask-demo/AR-Face-Mask/node_modules/@zappar/zappar/lib/zappar.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","loadedPromise","loaded","browserIncompatibleUI","browserIncompatible","drawPlane","projectionMatrixFromCameraModel","invert","cameraDefaultDeviceID","z","zappar_cv_1","require","gl_matrix_1","version_1","_z","console","log","VERSION","initialize","userFacing","camera_default_device_id","m","ret","mat4","create","model","renderWidth","renderHeight","zNear","zFar","projection_matrix_from_camera_model_ext","gl","projectionMatrix","cameraMatrix","targetMatrix","texture","draw_plane","browser_incompatible","browser_incompatible_ui","delay","ms","setTimeout"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.loadedPromise = exports.loaded = exports.browserIncompatibleUI = exports.browserIncompatible = exports.drawPlane = exports.projectionMatrixFromCameraModel = exports.invert = exports.cameraDefaultDeviceID = exports.z = void 0;\nconst zappar_cv_1 = require(\"@zappar/zappar-cv\");\nconst gl_matrix_1 = require(\"gl-matrix\");\nconst version_1 = require(\"./version\");\nlet _z;\n/**\n * @ignore\n*/\nfunction z() {\n    if (!_z) {\n        console.log(`Zappar JS v${version_1.VERSION}`);\n        _z = zappar_cv_1.initialize();\n    }\n    return _z;\n}\nexports.z = z;\n/**\n * Gets the ID or the default rear- or user-facing camera.\n * @param userFacing - Whether 'selfie' camera ID should be returned.\n * @returns The camera device ID.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices\n*/\nfunction cameraDefaultDeviceID(userFacing) {\n    return z().camera_default_device_id(userFacing || false);\n}\nexports.cameraDefaultDeviceID = cameraDefaultDeviceID;\n/**\n * Inverts a 4x4 Float32Array Matrix.\n * @param m - The 4x4 matrix to be inverted.\n * @returns The inverted Float32Array matrix.\n*/\nfunction invert(m) {\n    const ret = gl_matrix_1.mat4.create();\n    gl_matrix_1.mat4.invert(ret, m);\n    return ret;\n}\nexports.invert = invert;\n/**\n  * Calculates the projection matrix from a given camera model (i.e. intrinsic camera parameters)\n  * @param model - The camera model.\n  * @param renderWidth - The width of the canvas.\n  * @param renderHeight - The height of the canvas.\n  * @param zNear - The near clipping plane.\n  * @param zFar - The far clipping plane.\n  * @returns A 4x4 column-major projection matrix.\n */\nfunction projectionMatrixFromCameraModel(model, renderWidth, renderHeight, zNear = 0.1, zFar = 100) {\n    return z().projection_matrix_from_camera_model_ext(model, renderWidth, renderHeight, zNear, zFar);\n}\nexports.projectionMatrixFromCameraModel = projectionMatrixFromCameraModel;\n/**\n * @ignore\n*/\nfunction drawPlane(gl, projectionMatrix, cameraMatrix, targetMatrix, texture) {\n    z().draw_plane(gl, projectionMatrix, cameraMatrix, targetMatrix, texture);\n}\nexports.drawPlane = drawPlane;\n/**\n * Detects if your page is running in a browser that's not supported\n * @returns 'true' if the browser is incompatible.\n*/\nfunction browserIncompatible() {\n    return z().browser_incompatible();\n}\nexports.browserIncompatible = browserIncompatible;\n/**\n * Shows a full-page dialog that informs the user they're using an unsupported browser,\n * and provides a button to 'copy' the current page URL so they can 'paste' it into the\n * address bar of a compatible alternative.\n*/\nfunction browserIncompatibleUI() {\n    z().browser_incompatible_ui();\n}\nexports.browserIncompatibleUI = browserIncompatibleUI;\n/**\n * Check if the Zappar library is fully loaded and ready to process data.\n * Note that you can still use the full API before this function returns true - it's here to help implement loading screens.\n *\n * @returns 'true' if the library is fully loaded.\n*/\nfunction loaded() {\n    return z().loaded();\n}\nexports.loaded = loaded;\n/**\n * Gets a promise that resolves when the Zappar library is fully loaded and ready to process data.\n * Note that you can still use the full API before this promise is resolved - it's here to help implement loading screens.\n *\n * @returns a promise that resolves when the library is fully loaded.\n*/\nfunction loadedPromise() {\n    return __awaiter(this, void 0, void 0, function* () {\n        while (true) {\n            if (loaded())\n                return;\n            yield delay(50);\n        }\n    });\n}\nexports.loadedPromise = loadedPromise;\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n"]},"metadata":{},"sourceType":"script"}