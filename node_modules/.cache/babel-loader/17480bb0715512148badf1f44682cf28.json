{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FaceLandmark = exports.getFaceLandmark = exports.destroyFaceLandmark = exports.createFaceLandmark = void 0;\n\nconst gl_matrix_1 = require(\"gl-matrix\");\n\nconst facelandmarkdata_1 = require(\"./facelandmarkdata\");\n\nconst loglevel_1 = require(\"./loglevel\");\n\nlet latestFaceLandmark = 1;\nlet faceLandmarkById = new Map();\n\nfunction createFaceLandmark(n) {\n  let ret = latestFaceLandmark++;\n  faceLandmarkById.set(ret, new FaceLandmark(n));\n  loglevel_1.zcout(\"face_landmark_t initialized\");\n  return ret;\n}\n\nexports.createFaceLandmark = createFaceLandmark;\n\nfunction destroyFaceLandmark(m) {\n  faceLandmarkById.delete(m);\n}\n\nexports.destroyFaceLandmark = destroyFaceLandmark;\n\nfunction getFaceLandmark(m) {\n  return faceLandmarkById.get(m);\n}\n\nexports.getFaceLandmark = getFaceLandmark;\n\nclass FaceLandmark {\n  constructor(_name) {\n    this._name = _name;\n    this.anchor_pose = gl_matrix_1.mat4.create();\n  }\n\n  _getVertex(identity, expression, data) {\n    let vert = data.mean.slice();\n\n    for (let i = 0; i < 50; i++) {\n      vert[0] += identity[i] * data.identity[i * 3 + 0];\n      vert[1] += identity[i] * data.identity[i * 3 + 1];\n      vert[2] += identity[i] * data.identity[i * 3 + 2];\n    }\n\n    for (let i = 0; i < 29; i++) {\n      vert[0] += expression[i] * data.expression[i * 3 + 0];\n      vert[1] += expression[i] * data.expression[i * 3 + 1];\n      vert[2] += expression[i] * data.expression[i * 3 + 2];\n    }\n\n    return vert;\n  }\n\n  update(identity, expression, mirrored) {\n    let vert;\n\n    let data = facelandmarkdata_1.landmarkData[this._name.toString()];\n\n    if (!data) return;\n\n    if (Array.isArray(data)) {\n      vert = this._getVertex(identity, expression, data[0]);\n\n      let b = this._getVertex(identity, expression, data[1]);\n\n      vert[0] = 0.5 * (vert[0] + b[0]);\n      vert[1] = 0.5 * (vert[1] + b[1]);\n      vert[2] = 0.5 * (vert[2] + b[2]);\n    } else {\n      vert = this._getVertex(identity, expression, data);\n    }\n\n    if (mirrored) vert[0] *= -1;\n    gl_matrix_1.mat4.fromTranslation(this.anchor_pose, vert);\n  }\n\n}\n\nexports.FaceLandmark = FaceLandmark;","map":{"version":3,"sources":["/Users/StanleyWalker/Desktop/react-three-example-face-tracking-helmet-1/node_modules/@zappar/zappar-cv/lib/facelandmark.js"],"names":["Object","defineProperty","exports","value","FaceLandmark","getFaceLandmark","destroyFaceLandmark","createFaceLandmark","gl_matrix_1","require","facelandmarkdata_1","loglevel_1","latestFaceLandmark","faceLandmarkById","Map","n","ret","set","zcout","m","delete","get","constructor","_name","anchor_pose","mat4","create","_getVertex","identity","expression","data","vert","mean","slice","i","update","mirrored","landmarkData","toString","Array","isArray","b","fromTranslation"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FaceLandmark = exports.getFaceLandmark = exports.destroyFaceLandmark = exports.createFaceLandmark = void 0;\nconst gl_matrix_1 = require(\"gl-matrix\");\nconst facelandmarkdata_1 = require(\"./facelandmarkdata\");\nconst loglevel_1 = require(\"./loglevel\");\nlet latestFaceLandmark = 1;\nlet faceLandmarkById = new Map();\nfunction createFaceLandmark(n) {\n    let ret = (latestFaceLandmark++);\n    faceLandmarkById.set(ret, new FaceLandmark(n));\n    loglevel_1.zcout(\"face_landmark_t initialized\");\n    return ret;\n}\nexports.createFaceLandmark = createFaceLandmark;\nfunction destroyFaceLandmark(m) {\n    faceLandmarkById.delete(m);\n}\nexports.destroyFaceLandmark = destroyFaceLandmark;\nfunction getFaceLandmark(m) {\n    return faceLandmarkById.get(m);\n}\nexports.getFaceLandmark = getFaceLandmark;\nclass FaceLandmark {\n    constructor(_name) {\n        this._name = _name;\n        this.anchor_pose = gl_matrix_1.mat4.create();\n    }\n    _getVertex(identity, expression, data) {\n        let vert = data.mean.slice();\n        for (let i = 0; i < 50; i++) {\n            vert[0] += identity[i] * data.identity[i * 3 + 0];\n            vert[1] += identity[i] * data.identity[i * 3 + 1];\n            vert[2] += identity[i] * data.identity[i * 3 + 2];\n        }\n        for (let i = 0; i < 29; i++) {\n            vert[0] += expression[i] * data.expression[i * 3 + 0];\n            vert[1] += expression[i] * data.expression[i * 3 + 1];\n            vert[2] += expression[i] * data.expression[i * 3 + 2];\n        }\n        return vert;\n    }\n    update(identity, expression, mirrored) {\n        let vert;\n        let data = facelandmarkdata_1.landmarkData[this._name.toString()];\n        if (!data)\n            return;\n        if (Array.isArray(data)) {\n            vert = this._getVertex(identity, expression, data[0]);\n            let b = this._getVertex(identity, expression, data[1]);\n            vert[0] = 0.5 * (vert[0] + b[0]);\n            vert[1] = 0.5 * (vert[1] + b[1]);\n            vert[2] = 0.5 * (vert[2] + b[2]);\n        }\n        else {\n            vert = this._getVertex(identity, expression, data);\n        }\n        if (mirrored)\n            vert[0] *= -1;\n        gl_matrix_1.mat4.fromTranslation(this.anchor_pose, vert);\n    }\n}\nexports.FaceLandmark = FaceLandmark;\n"]},"metadata":{},"sourceType":"script"}