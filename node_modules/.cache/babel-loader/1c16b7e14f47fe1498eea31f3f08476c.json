{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FaceTracker = void 0;\n\nconst event_1 = require(\"./event\");\n\nconst zappar_1 = require(\"./zappar\");\n/**\n * Attaches content to a face as it moves around in the camera view.\n * @see https://docs.zap.works/universal-ar/javascript/face-tracking/\n */\n\n\nclass FaceTracker {\n  /**\n   * Constructs a new FaceTracker\n   * @param _pipeline - The pipeline that this tracker will operate within.\n  */\n  constructor(_pipeline) {\n    this._pipeline = _pipeline;\n    /**\n    * Emitted when an anchor becomes visible in a camera frame.\n    */\n\n    this.onVisible = new event_1.Event1();\n    /**\n    * Emitted when an anchor goes from being visible in the previous camera frame, to not being visible in the current frame.\n    */\n\n    this.onNotVisible = new event_1.Event1();\n    /**\n    * Emitted when a new anchor is created by the tracker.\n    */\n\n    this.onNewAnchor = new event_1.Event1();\n    /**\n     * The set of currently visible anchors.\n     */\n\n    this.visible = new Set();\n    /**\n    * A map of the available anchors by their respective IDs.\n    */\n\n    this.anchors = new Map();\n    this._visibleLastFrame = new Set();\n\n    this._frameUpdate = () => {\n      const newAnchors = new Set(); // Swap the visible and visibleLastFrame so we can avoid a set allocation\n\n      const swap = this.visible;\n      this.visible = this._visibleLastFrame;\n      this._visibleLastFrame = swap;\n      this.visible.clear();\n\n      const num = this._z.face_tracker_anchor_count(this._impl);\n\n      for (let i = 0; i < num; i++) {\n        const id = this._z.face_tracker_anchor_id(this._impl, i);\n\n        let anchor = this.anchors.get(id);\n        let isNew = false;\n\n        if (!anchor) {\n          anchor = {\n            onVisible: new event_1.Event(),\n            onNotVisible: new event_1.Event(),\n            indx: 0,\n            id: id,\n            poseCameraRelative: mirror => this._z.face_tracker_anchor_pose_camera_relative(this._impl, anchor.indx, mirror === true),\n            pose: (cameraPose, mirror) => this._z.face_tracker_anchor_pose(this._impl, anchor.indx, cameraPose, mirror === true),\n            identity: new Float32Array(50),\n            expression: new Float32Array(29),\n            visible: true\n          };\n          isNew = true;\n          this.anchors.set(id, anchor);\n          newAnchors.add(anchor);\n        }\n\n        anchor.indx = i;\n        anchor.visible = true;\n        anchor.identity = this._z.face_tracker_anchor_identity_coefficients(this._impl, i);\n        anchor.expression = this._z.face_tracker_anchor_expression_coefficients(this._impl, i);\n        this.visible.add(anchor);\n      } // Events\n\n\n      for (const anchor of newAnchors) this.onNewAnchor.emit(anchor);\n\n      for (const anchor of this.visible) {\n        if (!this._visibleLastFrame.has(anchor)) {\n          this.onVisible.emit(anchor);\n          anchor.onVisible.emit();\n        } else {\n          this._visibleLastFrame.delete(anchor);\n        }\n      }\n\n      for (const anchor of this._visibleLastFrame) {\n        this.onNotVisible.emit(anchor);\n        anchor.onNotVisible.emit();\n      }\n    };\n\n    this._pipeline._onFrameUpdateInternal.bind(this._frameUpdate);\n\n    this._z = zappar_1.z();\n    this._impl = this._z.face_tracker_create(this._pipeline._getImpl());\n  }\n  /**\n    * Destroys the face tracker.\n   */\n\n\n  destroy() {\n    this._pipeline._onFrameUpdateInternal.unbind(this._frameUpdate);\n\n    this.anchors.clear();\n    this.visible.clear();\n\n    this._z.face_tracker_destroy(this._impl);\n  }\n  /**\n   * Loads face tracking model data.\n   * @param src - A URL to, or ArrayBuffer of, model data.\n   * @returns A promise that's resolved once the model is loaded. It may still take a few frames for the tracker to fully initialize and detect faces.\n  */\n\n\n  loadModel(src) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof src === \"string\") {\n        src = yield (yield fetch(src)).arrayBuffer();\n      }\n\n      this._z.face_tracker_model_load_from_memory(this._impl, src);\n    });\n  }\n  /**\n   * Loads the default face tracking model.\n   * @returns A promise that's resolved once the model is loaded. It may still take a few frames for the tracker to fully initialize and detect faces.\n  */\n\n\n  loadDefaultModel() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this._z.face_tracker_model_load_default(this._impl);\n    });\n  }\n  /**\n   * Gets/sets the enabled state of the face tracker.\n   * Disable when not in use to save computational resources during frame processing.\n   */\n\n\n  get enabled() {\n    return this._z.face_tracker_enabled(this._impl);\n  }\n\n  set enabled(e) {\n    this._z.face_tracker_enabled_set(this._impl, e);\n  }\n  /**\n   * Gets/sets the maximum number of faces to track.\n   *\n   * By default only one face is tracked in any given frame. Increasing this number may reduce runtime performance.\n   */\n\n\n  get maxFaces() {\n    return this._z.face_tracker_max_faces(this._impl);\n  }\n\n  set maxFaces(m) {\n    this._z.face_tracker_max_faces_set(this._impl, m);\n  }\n\n}\n\nexports.FaceTracker = FaceTracker;","map":{"version":3,"sources":["/Users/StanleyWalker/Desktop/face-mask-demo/AR-Face-Mask/node_modules/@zappar/zappar/lib/facetracker.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","FaceTracker","event_1","require","zappar_1","constructor","_pipeline","onVisible","Event1","onNotVisible","onNewAnchor","visible","Set","anchors","Map","_visibleLastFrame","_frameUpdate","newAnchors","swap","clear","num","_z","face_tracker_anchor_count","_impl","i","id","face_tracker_anchor_id","anchor","get","isNew","Event","indx","poseCameraRelative","mirror","face_tracker_anchor_pose_camera_relative","pose","cameraPose","face_tracker_anchor_pose","identity","Float32Array","expression","set","add","face_tracker_anchor_identity_coefficients","face_tracker_anchor_expression_coefficients","emit","has","delete","_onFrameUpdateInternal","bind","z","face_tracker_create","_getImpl","destroy","unbind","face_tracker_destroy","loadModel","src","fetch","arrayBuffer","face_tracker_model_load_from_memory","loadDefaultModel","face_tracker_model_load_default","enabled","face_tracker_enabled","face_tracker_enabled_set","maxFaces","face_tracker_max_faces","m","face_tracker_max_faces_set"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FaceTracker = void 0;\nconst event_1 = require(\"./event\");\nconst zappar_1 = require(\"./zappar\");\n/**\n * Attaches content to a face as it moves around in the camera view.\n * @see https://docs.zap.works/universal-ar/javascript/face-tracking/\n */\nclass FaceTracker {\n    /**\n     * Constructs a new FaceTracker\n     * @param _pipeline - The pipeline that this tracker will operate within.\n    */\n    constructor(_pipeline) {\n        this._pipeline = _pipeline;\n        /**\n        * Emitted when an anchor becomes visible in a camera frame.\n        */\n        this.onVisible = new event_1.Event1();\n        /**\n        * Emitted when an anchor goes from being visible in the previous camera frame, to not being visible in the current frame.\n        */\n        this.onNotVisible = new event_1.Event1();\n        /**\n        * Emitted when a new anchor is created by the tracker.\n        */\n        this.onNewAnchor = new event_1.Event1();\n        /**\n         * The set of currently visible anchors.\n         */\n        this.visible = new Set();\n        /**\n        * A map of the available anchors by their respective IDs.\n        */\n        this.anchors = new Map();\n        this._visibleLastFrame = new Set();\n        this._frameUpdate = () => {\n            const newAnchors = new Set();\n            // Swap the visible and visibleLastFrame so we can avoid a set allocation\n            const swap = this.visible;\n            this.visible = this._visibleLastFrame;\n            this._visibleLastFrame = swap;\n            this.visible.clear();\n            const num = this._z.face_tracker_anchor_count(this._impl);\n            for (let i = 0; i < num; i++) {\n                const id = this._z.face_tracker_anchor_id(this._impl, i);\n                let anchor = this.anchors.get(id);\n                let isNew = false;\n                if (!anchor) {\n                    anchor = {\n                        onVisible: new event_1.Event(),\n                        onNotVisible: new event_1.Event(),\n                        indx: 0,\n                        id: id,\n                        poseCameraRelative: mirror => this._z.face_tracker_anchor_pose_camera_relative(this._impl, anchor.indx, mirror === true),\n                        pose: (cameraPose, mirror) => this._z.face_tracker_anchor_pose(this._impl, anchor.indx, cameraPose, mirror === true),\n                        identity: new Float32Array(50),\n                        expression: new Float32Array(29),\n                        visible: true\n                    };\n                    isNew = true;\n                    this.anchors.set(id, anchor);\n                    newAnchors.add(anchor);\n                }\n                anchor.indx = i;\n                anchor.visible = true;\n                anchor.identity = this._z.face_tracker_anchor_identity_coefficients(this._impl, i);\n                anchor.expression = this._z.face_tracker_anchor_expression_coefficients(this._impl, i);\n                this.visible.add(anchor);\n            }\n            // Events\n            for (const anchor of newAnchors)\n                this.onNewAnchor.emit(anchor);\n            for (const anchor of this.visible) {\n                if (!this._visibleLastFrame.has(anchor)) {\n                    this.onVisible.emit(anchor);\n                    anchor.onVisible.emit();\n                }\n                else {\n                    this._visibleLastFrame.delete(anchor);\n                }\n            }\n            for (const anchor of this._visibleLastFrame) {\n                this.onNotVisible.emit(anchor);\n                anchor.onNotVisible.emit();\n            }\n        };\n        this._pipeline._onFrameUpdateInternal.bind(this._frameUpdate);\n        this._z = zappar_1.z();\n        this._impl = this._z.face_tracker_create(this._pipeline._getImpl());\n    }\n    /**\n      * Destroys the face tracker.\n     */\n    destroy() {\n        this._pipeline._onFrameUpdateInternal.unbind(this._frameUpdate);\n        this.anchors.clear();\n        this.visible.clear();\n        this._z.face_tracker_destroy(this._impl);\n    }\n    /**\n     * Loads face tracking model data.\n     * @param src - A URL to, or ArrayBuffer of, model data.\n     * @returns A promise that's resolved once the model is loaded. It may still take a few frames for the tracker to fully initialize and detect faces.\n    */\n    loadModel(src) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof src === \"string\") {\n                src = yield (yield fetch(src)).arrayBuffer();\n            }\n            this._z.face_tracker_model_load_from_memory(this._impl, src);\n        });\n    }\n    /**\n     * Loads the default face tracking model.\n     * @returns A promise that's resolved once the model is loaded. It may still take a few frames for the tracker to fully initialize and detect faces.\n    */\n    loadDefaultModel() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._z.face_tracker_model_load_default(this._impl);\n        });\n    }\n    /**\n     * Gets/sets the enabled state of the face tracker.\n     * Disable when not in use to save computational resources during frame processing.\n     */\n    get enabled() {\n        return this._z.face_tracker_enabled(this._impl);\n    }\n    set enabled(e) {\n        this._z.face_tracker_enabled_set(this._impl, e);\n    }\n    /**\n     * Gets/sets the maximum number of faces to track.\n     *\n     * By default only one face is tracked in any given frame. Increasing this number may reduce runtime performance.\n     */\n    get maxFaces() {\n        return this._z.face_tracker_max_faces(this._impl);\n    }\n    set maxFaces(m) {\n        this._z.face_tracker_max_faces_set(this._impl, m);\n    }\n}\nexports.FaceTracker = FaceTracker;\n"]},"metadata":{},"sourceType":"script"}