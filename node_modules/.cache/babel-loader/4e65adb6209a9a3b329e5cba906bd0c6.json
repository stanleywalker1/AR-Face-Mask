{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cameraRotationForScreenOrientation = exports.projectionMatrix = void 0;\n\nconst gl_matrix_1 = require(\"gl-matrix\");\n\nfunction projectionMatrix(params, screenWidth, screenHeight) {\n  let near = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.01;\n  let far = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 100.0;\n  let cam_x = params[2] * 2;\n  let cam_y = params[3] * 2;\n  let projection = gl_matrix_1.mat4.create();\n  gl_matrix_1.mat4.frustum(projection, near * (-0.5 - params[2]) / params[0], near * (cam_x - 0.5 - params[2]) / params[0], near * (cam_y - 0.5 - params[3]) / params[1], near * (-0.5 - params[3]) / params[1], near, far); // Flip camera y axis (before any other transformations) - converts from\n  // the y axis downwards of the  tracking camera models to the y axis upwards\n  // of rendering coordinate systems\n\n  projection[4] *= -1.0;\n  projection[5] *= -1.0;\n  projection[6] *= -1.0;\n  projection[7] *= -1.0;\n  let mult = gl_matrix_1.mat4.create();\n  gl_matrix_1.mat4.fromScaling(mult, [0.5 * cam_x, 0.5 * cam_y, 1]);\n  gl_matrix_1.mat4.multiply(projection, mult, projection); // If it's user facing or not doesn't matter here as long as we apply the same-but-opposite\n  // rotation at the end of the function\n\n  gl_matrix_1.mat4.fromRotation(mult, cameraRotationForScreenOrientation(false) * Math.PI / 180.0, [0, 0, 1]);\n  gl_matrix_1.mat4.multiply(projection, mult, projection);\n  let vec = gl_matrix_1.vec3.create();\n  vec[0] = cam_x;\n  vec[1] = cam_y;\n  vec[2] = 0;\n  gl_matrix_1.vec3.transformMat4(vec, vec, mult);\n  let absWidth = Math.abs(vec[0]);\n  let absHeight = Math.abs(vec[1]);\n  let scaleFactor = 1;\n\n  if (absWidth / screenWidth > absHeight / screenHeight) {\n    scaleFactor = screenHeight / absHeight;\n  } else {\n    scaleFactor = screenWidth / absWidth;\n  }\n\n  gl_matrix_1.mat4.fromScaling(mult, [scaleFactor, scaleFactor, 1]);\n  gl_matrix_1.mat4.multiply(projection, mult, projection);\n  gl_matrix_1.mat4.fromScaling(mult, [2 / screenWidth, 2 / screenHeight, 1]);\n  gl_matrix_1.mat4.multiply(projection, mult, projection);\n  gl_matrix_1.mat4.fromRotation(mult, cameraRotationForScreenOrientation(false) * Math.PI / -180.0, [0, 0, 1]);\n  gl_matrix_1.mat4.multiply(projection, projection, mult);\n  return projection;\n}\n\nexports.projectionMatrix = projectionMatrix;\n\nfunction cameraRotationForScreenOrientation(isUserFacing) {\n  if (window.screen.orientation) {\n    switch (window.screen.orientation.type) {\n      case \"portrait-primary\":\n        return isUserFacing ? 90 : 270;\n\n      case \"landscape-secondary\":\n        return 180;\n\n      case \"portrait-secondary\":\n        return isUserFacing ? 270 : 90;\n\n      default:\n        return 0;\n    }\n  } else if (window.orientation !== undefined) {\n    switch (window.orientation) {\n      case 0:\n        return isUserFacing ? 90 : 270;\n\n      case 90:\n        return 0;\n\n      case 180:\n        return isUserFacing ? 270 : 90;\n\n      case -90:\n        return 180;\n    }\n  }\n\n  return 0;\n}\n\nexports.cameraRotationForScreenOrientation = cameraRotationForScreenOrientation;","map":{"version":3,"sources":["/Users/StanleyWalker/Desktop/react-three-example-face-tracking-helmet-1/node_modules/@zappar/zappar-cv/lib/cameramodel.js"],"names":["Object","defineProperty","exports","value","cameraRotationForScreenOrientation","projectionMatrix","gl_matrix_1","require","params","screenWidth","screenHeight","near","far","cam_x","cam_y","projection","mat4","create","frustum","mult","fromScaling","multiply","fromRotation","Math","PI","vec","vec3","transformMat4","absWidth","abs","absHeight","scaleFactor","isUserFacing","window","screen","orientation","type","undefined"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,kCAAR,GAA6CF,OAAO,CAACG,gBAAR,GAA2B,KAAK,CAA7E;;AACA,MAAMC,WAAW,GAAGC,OAAO,CAAC,WAAD,CAA3B;;AACA,SAASF,gBAAT,CAA0BG,MAA1B,EAAkCC,WAAlC,EAA+CC,YAA/C,EAAuF;AAAA,MAA1BC,IAA0B,uEAAnB,IAAmB;AAAA,MAAbC,GAAa,uEAAP,KAAO;AACnF,MAAIC,KAAK,GAAGL,MAAM,CAAC,CAAD,CAAN,GAAY,CAAxB;AACA,MAAIM,KAAK,GAAGN,MAAM,CAAC,CAAD,CAAN,GAAY,CAAxB;AACA,MAAIO,UAAU,GAAGT,WAAW,CAACU,IAAZ,CAAiBC,MAAjB,EAAjB;AACAX,EAAAA,WAAW,CAACU,IAAZ,CAAiBE,OAAjB,CAAyBH,UAAzB,EAAqCJ,IAAI,IAAI,CAAC,GAAD,GAAOH,MAAM,CAAC,CAAD,CAAjB,CAAJ,GAA4BA,MAAM,CAAC,CAAD,CAAvE,EAA4EG,IAAI,IAAIE,KAAK,GAAG,GAAR,GAAcL,MAAM,CAAC,CAAD,CAAxB,CAAJ,GAAmCA,MAAM,CAAC,CAAD,CAArH,EAA0HG,IAAI,IAAIG,KAAK,GAAG,GAAR,GAAcN,MAAM,CAAC,CAAD,CAAxB,CAAJ,GAAmCA,MAAM,CAAC,CAAD,CAAnK,EAAwKG,IAAI,IAAI,CAAC,GAAD,GAAOH,MAAM,CAAC,CAAD,CAAjB,CAAJ,GAA4BA,MAAM,CAAC,CAAD,CAA1M,EAA+MG,IAA/M,EAAqNC,GAArN,EAJmF,CAKnF;AACA;AACA;;AACAG,EAAAA,UAAU,CAAC,CAAD,CAAV,IAAiB,CAAC,GAAlB;AACAA,EAAAA,UAAU,CAAC,CAAD,CAAV,IAAiB,CAAC,GAAlB;AACAA,EAAAA,UAAU,CAAC,CAAD,CAAV,IAAiB,CAAC,GAAlB;AACAA,EAAAA,UAAU,CAAC,CAAD,CAAV,IAAiB,CAAC,GAAlB;AACA,MAAII,IAAI,GAAGb,WAAW,CAACU,IAAZ,CAAiBC,MAAjB,EAAX;AACAX,EAAAA,WAAW,CAACU,IAAZ,CAAiBI,WAAjB,CAA6BD,IAA7B,EAAmC,CAAC,MAAMN,KAAP,EAAc,MAAMC,KAApB,EAA2B,CAA3B,CAAnC;AACAR,EAAAA,WAAW,CAACU,IAAZ,CAAiBK,QAAjB,CAA0BN,UAA1B,EAAsCI,IAAtC,EAA4CJ,UAA5C,EAdmF,CAenF;AACA;;AACAT,EAAAA,WAAW,CAACU,IAAZ,CAAiBM,YAAjB,CAA8BH,IAA9B,EAAoCf,kCAAkC,CAAC,KAAD,CAAlC,GAA4CmB,IAAI,CAACC,EAAjD,GAAsD,KAA1F,EAAiG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAjG;AACAlB,EAAAA,WAAW,CAACU,IAAZ,CAAiBK,QAAjB,CAA0BN,UAA1B,EAAsCI,IAAtC,EAA4CJ,UAA5C;AACA,MAAIU,GAAG,GAAGnB,WAAW,CAACoB,IAAZ,CAAiBT,MAAjB,EAAV;AACAQ,EAAAA,GAAG,CAAC,CAAD,CAAH,GAASZ,KAAT;AACAY,EAAAA,GAAG,CAAC,CAAD,CAAH,GAASX,KAAT;AACAW,EAAAA,GAAG,CAAC,CAAD,CAAH,GAAS,CAAT;AACAnB,EAAAA,WAAW,CAACoB,IAAZ,CAAiBC,aAAjB,CAA+BF,GAA/B,EAAoCA,GAApC,EAAyCN,IAAzC;AACA,MAAIS,QAAQ,GAAGL,IAAI,CAACM,GAAL,CAASJ,GAAG,CAAC,CAAD,CAAZ,CAAf;AACA,MAAIK,SAAS,GAAGP,IAAI,CAACM,GAAL,CAASJ,GAAG,CAAC,CAAD,CAAZ,CAAhB;AACA,MAAIM,WAAW,GAAG,CAAlB;;AACA,MAAIH,QAAQ,GAAGnB,WAAX,GAAyBqB,SAAS,GAAGpB,YAAzC,EAAuD;AACnDqB,IAAAA,WAAW,GAAGrB,YAAY,GAAGoB,SAA7B;AACH,GAFD,MAGK;AACDC,IAAAA,WAAW,GAAGtB,WAAW,GAAGmB,QAA5B;AACH;;AACDtB,EAAAA,WAAW,CAACU,IAAZ,CAAiBI,WAAjB,CAA6BD,IAA7B,EAAmC,CAACY,WAAD,EAAcA,WAAd,EAA2B,CAA3B,CAAnC;AACAzB,EAAAA,WAAW,CAACU,IAAZ,CAAiBK,QAAjB,CAA0BN,UAA1B,EAAsCI,IAAtC,EAA4CJ,UAA5C;AACAT,EAAAA,WAAW,CAACU,IAAZ,CAAiBI,WAAjB,CAA6BD,IAA7B,EAAmC,CAAC,IAAIV,WAAL,EAAkB,IAAIC,YAAtB,EAAoC,CAApC,CAAnC;AACAJ,EAAAA,WAAW,CAACU,IAAZ,CAAiBK,QAAjB,CAA0BN,UAA1B,EAAsCI,IAAtC,EAA4CJ,UAA5C;AACAT,EAAAA,WAAW,CAACU,IAAZ,CAAiBM,YAAjB,CAA8BH,IAA9B,EAAoCf,kCAAkC,CAAC,KAAD,CAAlC,GAA4CmB,IAAI,CAACC,EAAjD,GAAsD,CAAC,KAA3F,EAAkG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAlG;AACAlB,EAAAA,WAAW,CAACU,IAAZ,CAAiBK,QAAjB,CAA0BN,UAA1B,EAAsCA,UAAtC,EAAkDI,IAAlD;AACA,SAAOJ,UAAP;AACH;;AACDb,OAAO,CAACG,gBAAR,GAA2BA,gBAA3B;;AACA,SAASD,kCAAT,CAA4C4B,YAA5C,EAA0D;AACtD,MAAIC,MAAM,CAACC,MAAP,CAAcC,WAAlB,EAA+B;AAC3B,YAAQF,MAAM,CAACC,MAAP,CAAcC,WAAd,CAA0BC,IAAlC;AACI,WAAK,kBAAL;AACI,eAAOJ,YAAY,GAAG,EAAH,GAAQ,GAA3B;;AACJ,WAAK,qBAAL;AACI,eAAO,GAAP;;AACJ,WAAK,oBAAL;AACI,eAAOA,YAAY,GAAG,GAAH,GAAS,EAA5B;;AACJ;AACI,eAAO,CAAP;AARR;AAUH,GAXD,MAYK,IAAIC,MAAM,CAACE,WAAP,KAAuBE,SAA3B,EAAsC;AACvC,YAAQJ,MAAM,CAACE,WAAf;AACI,WAAK,CAAL;AAAQ,eAAOH,YAAY,GAAG,EAAH,GAAQ,GAA3B;;AACR,WAAK,EAAL;AAAS,eAAO,CAAP;;AACT,WAAK,GAAL;AAAU,eAAOA,YAAY,GAAG,GAAH,GAAS,EAA5B;;AACV,WAAK,CAAC,EAAN;AAAU,eAAO,GAAP;AAJd;AAMH;;AACD,SAAO,CAAP;AACH;;AACD9B,OAAO,CAACE,kCAAR,GAA6CA,kCAA7C","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cameraRotationForScreenOrientation = exports.projectionMatrix = void 0;\nconst gl_matrix_1 = require(\"gl-matrix\");\nfunction projectionMatrix(params, screenWidth, screenHeight, near = 0.01, far = 100.0) {\n    let cam_x = params[2] * 2;\n    let cam_y = params[3] * 2;\n    let projection = gl_matrix_1.mat4.create();\n    gl_matrix_1.mat4.frustum(projection, near * (-0.5 - params[2]) / params[0], near * (cam_x - 0.5 - params[2]) / params[0], near * (cam_y - 0.5 - params[3]) / params[1], near * (-0.5 - params[3]) / params[1], near, far);\n    // Flip camera y axis (before any other transformations) - converts from\n    // the y axis downwards of the  tracking camera models to the y axis upwards\n    // of rendering coordinate systems\n    projection[4] *= -1.0;\n    projection[5] *= -1.0;\n    projection[6] *= -1.0;\n    projection[7] *= -1.0;\n    let mult = gl_matrix_1.mat4.create();\n    gl_matrix_1.mat4.fromScaling(mult, [0.5 * cam_x, 0.5 * cam_y, 1]);\n    gl_matrix_1.mat4.multiply(projection, mult, projection);\n    // If it's user facing or not doesn't matter here as long as we apply the same-but-opposite\n    // rotation at the end of the function\n    gl_matrix_1.mat4.fromRotation(mult, cameraRotationForScreenOrientation(false) * Math.PI / 180.0, [0, 0, 1]);\n    gl_matrix_1.mat4.multiply(projection, mult, projection);\n    let vec = gl_matrix_1.vec3.create();\n    vec[0] = cam_x;\n    vec[1] = cam_y;\n    vec[2] = 0;\n    gl_matrix_1.vec3.transformMat4(vec, vec, mult);\n    let absWidth = Math.abs(vec[0]);\n    let absHeight = Math.abs(vec[1]);\n    let scaleFactor = 1;\n    if (absWidth / screenWidth > absHeight / screenHeight) {\n        scaleFactor = screenHeight / absHeight;\n    }\n    else {\n        scaleFactor = screenWidth / absWidth;\n    }\n    gl_matrix_1.mat4.fromScaling(mult, [scaleFactor, scaleFactor, 1]);\n    gl_matrix_1.mat4.multiply(projection, mult, projection);\n    gl_matrix_1.mat4.fromScaling(mult, [2 / screenWidth, 2 / screenHeight, 1]);\n    gl_matrix_1.mat4.multiply(projection, mult, projection);\n    gl_matrix_1.mat4.fromRotation(mult, cameraRotationForScreenOrientation(false) * Math.PI / -180.0, [0, 0, 1]);\n    gl_matrix_1.mat4.multiply(projection, projection, mult);\n    return projection;\n}\nexports.projectionMatrix = projectionMatrix;\nfunction cameraRotationForScreenOrientation(isUserFacing) {\n    if (window.screen.orientation) {\n        switch (window.screen.orientation.type) {\n            case \"portrait-primary\":\n                return isUserFacing ? 90 : 270;\n            case \"landscape-secondary\":\n                return 180;\n            case \"portrait-secondary\":\n                return isUserFacing ? 270 : 90;\n            default:\n                return 0;\n        }\n    }\n    else if (window.orientation !== undefined) {\n        switch (window.orientation) {\n            case 0: return isUserFacing ? 90 : 270;\n            case 90: return 0;\n            case 180: return isUserFacing ? 270 : 90;\n            case -90: return 180;\n        }\n    }\n    return 0;\n}\nexports.cameraRotationForScreenOrientation = cameraRotationForScreenOrientation;\n"]},"metadata":{},"sourceType":"script"}