{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetitionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = void 0;\n\nvar first_1 = __importDefault(require(\"lodash/first\"));\n\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nvar drop_1 = __importDefault(require(\"lodash/drop\"));\n\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\n\nvar filter_1 = __importDefault(require(\"lodash/filter\"));\n\nvar reject_1 = __importDefault(require(\"lodash/reject\"));\n\nvar difference_1 = __importDefault(require(\"lodash/difference\"));\n\nvar map_1 = __importDefault(require(\"lodash/map\"));\n\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nvar groupBy_1 = __importDefault(require(\"lodash/groupBy\"));\n\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\n\nvar pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\n\nvar values_1 = __importDefault(require(\"lodash/values\"));\n\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\n\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\n\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\n\nvar parser_1 = require(\"../parser/parser\");\n\nvar gast_1 = require(\"@chevrotain/gast\");\n\nvar lookahead_1 = require(\"./lookahead\");\n\nvar interpreter_1 = require(\"./interpreter\");\n\nvar gast_2 = require(\"@chevrotain/gast\");\n\nvar gast_3 = require(\"@chevrotain/gast\");\n\nvar dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\n\nvar compact_1 = __importDefault(require(\"lodash/compact\"));\n\nvar tokens_1 = require(\"../../scan/tokens\");\n\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = (0, flatMap_1.default)(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = (0, flatMap_1.default)(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = []; // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n\n  if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n    emptyAltErrors = (0, flatMap_1.default)(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = (0, flatMap_1.default)(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\n\nexports.validateGrammar = validateGrammar;\n\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = (0, pickBy_1.default)(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = (0, map_1.default)((0, values_1.default)(duplicates), function (currDuplicates) {\n    var firstProd = (0, first_1.default)(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = (0, gast_1.getProductionDslName)(firstProd);\n    var defError = {\n      message: msg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nfunction identifyProductionForDuplicates(prod) {\n  return \"\".concat((0, gast_1.getProductionDslName)(prod), \"_#_\").concat(prod.idx, \"_#_\").concat(getExtraProductionArgument(prod));\n}\n\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\n\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof gast_2.Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof gast_2.NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nvar OccurrenceValidationCollector =\n/** @class */\nfunction (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n\n  return OccurrenceValidationCollector;\n}(gast_3.GAstVisitor);\n\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\n\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = (0, reduce_1.default)(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n\n    return result;\n  }, 0);\n\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist; // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\n\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n\n  if (!(0, includes_1.default)(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\".concat(ruleName, \"<- cannot be overridden in the grammar: ->\").concat(className, \"<-\") + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\n\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n\n  if ((0, isEmpty_1.default)(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);\n\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    } // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n\n\n    var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function (currRefRule) {\n      var newPath = (0, clone_1.default)(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(errorsFromNextSteps);\n  }\n}\n\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\n\nfunction getFirstNoneTerminal(definition) {\n  var result = [];\n\n  if ((0, isEmpty_1.default)(definition)) {\n    return result;\n  }\n\n  var firstProd = (0, first_1.default)(definition);\n  /* istanbul ignore else */\n\n  if (firstProd instanceof gast_2.NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof gast_2.Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof gast_2.Terminal) {// nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);\n  var hasMore = definition.length > 1;\n\n  if (isFirstOptional && hasMore) {\n    var rest = (0, drop_1.default)(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\n\nvar OrCollector =\n/** @class */\nfunction (_super) {\n  __extends(OrCollector, _super);\n\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.alternations = [];\n    return _this;\n  }\n\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n\n  return OrCollector;\n}(gast_3.GAstVisitor);\n\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var exceptLast = (0, dropRight_1.default)(currOr.definition);\n    return (0, flatMap_1.default)(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);\n\n      if ((0, isEmpty_1.default)(possibleFirstInAlt)) {\n        return [{\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        }];\n      } else {\n        return [];\n      }\n    });\n  });\n  return errors;\n}\n\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\n\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations; // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n\n  ors = (0, reject_1.default)(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n  return errors;\n}\n\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\n\nvar RepetitionCollector =\n/** @class */\nfunction (_super) {\n  __extends(RepetitionCollector, _super);\n\n  function RepetitionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  RepetitionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  RepetitionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  RepetitionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  RepetitionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  return RepetitionCollector;\n}(gast_3.GAstVisitor);\n\nexports.RepetitionCollector = RepetitionCollector;\n\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    if (currOr.definition.length > 255) {\n      return [{\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      }];\n    } else {\n      return [];\n    }\n  });\n  return errors;\n}\n\nexports.validateTooManyAlts = validateTooManyAlts;\n\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  (0, forEach_1.default)(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    (0, forEach_1.default)(allRuleProductions, function (currProd) {\n      var prodType = (0, lookahead_1.getProdType)(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n\n      if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\n\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = (0, reduce_1.default)(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n\n    (0, forEach_1.default)(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      (0, forEach_1.default)(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n\n      if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = (0, map_1.default)(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    };\n  });\n  return currErrors;\n}\n\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  // flatten\n  var pathsAndIndices = (0, reduce_1.default)(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = (0, map_1.default)(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx]; // ignore (skip) ambiguities with this alternative\n\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return [];\n    }\n\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (// ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    return currPathPrefixErrors;\n  }));\n  return errors;\n}\n\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\n\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = (0, map_1.default)(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  (0, forEach_1.default)(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n\n    if ((0, includes_1.default)(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"mappings":"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","names":["validateGrammar","topLevels","globalMaxLookahead","tokenTypes","errMsgProvider","grammarName","duplicateErrors","currTopLevel","leftRecursionErrors","currTopRule","emptyAltErrors","ambiguousAltsErrors","emptyRepetitionErrors","validateSomeNonEmptyLookaheadPath","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","duplicateRulesError","concat","exports","validateDuplicateProductions","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","length","errors","currDuplicates","firstProd","msg","buildDuplicateFoundError","dslName","defError","message","type","parser_1","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","gast_2","terminalType","nonTerminalName","__extends","_this","subrule","push","option","manySep","atLeastOne","atLeastOneSep","many","or","terminal","gast_3","validateRuleDoesNotAlreadyExist","rule","allRules","className","occurrences","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","newPath","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","OrCollector","node","alternations","validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","currAlternative","currAltIdx","possibleFirstInAlt","tokens_1","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","validateAmbiguousAlternationAlternatives","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetitionCollector","validateTooManyAlts","buildTooManyAlternativesError","TOO_MANY_ALTS","topLevelRules","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currErrors","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sourceRoot":"","sources":["../../../../src/parse/grammar/checks.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}