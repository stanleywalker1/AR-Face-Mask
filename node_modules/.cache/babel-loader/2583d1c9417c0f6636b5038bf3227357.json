{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cameraFrameTextureMatrix = exports.CameraDraw = void 0;\n\nconst shader_1 = require(\"./shader\");\n\nconst gl_matrix_1 = require(\"gl-matrix\");\n\nclass CameraDraw {\n  constructor(_gl) {\n    this._gl = _gl;\n  }\n\n  dispose() {\n    if (this._vbo) this._gl.deleteBuffer(this._vbo);\n    this._vbo = undefined;\n    if (this._shader) this._gl.deleteProgram(this._shader.prog);\n    this._shader = undefined;\n  }\n\n  _generate(gl, i) {\n    if (this._vbo) return this._vbo;\n    if (!this._vbo) this._vbo = gl.createBuffer();\n    if (!this._vbo) throw new Error(\"Unable to create buffer object\");\n    let vboData = new Float32Array([-1, -1, 0, 0, 0, -1, 1, 0, 0, 1, 1, -1, 0, 1, 0, 1, -1, 0, 1, 0, -1, 1, 0, 0, 1, 1, 1, 0, 1, 1]);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vboData), gl.STATIC_DRAW);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    return this._vbo;\n  }\n\n  drawCameraFrame(screenWidth, screenHeight, i, mirror) {\n    if (!i.texture) return;\n    let gl = this._gl;\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.SCISSOR_TEST);\n    gl.disable(gl.CULL_FACE);\n    gl.disable(gl.BLEND);\n\n    let shader = this._getCameraShader(gl);\n\n    let vbo = this._generate(gl, i);\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.useProgram(shader.prog);\n    gl.uniformMatrix4fv(shader.unif_skinTexTransform, false, cameraFrameTextureMatrix(i.dataWidth, i.dataHeight, screenWidth, screenHeight, i.uvTransform, mirror));\n    gl.uniform1i(shader.unif_skinSampler, 0);\n    gl.bindTexture(gl.TEXTURE_2D, i.texture);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n    gl.vertexAttribPointer(shader.attr_position, 3, gl.FLOAT, false, 5 * 4, 0);\n    gl.enableVertexAttribArray(shader.attr_position);\n    gl.vertexAttribPointer(shader.attr_texCoord, 2, gl.FLOAT, false, 5 * 4, 3 * 4);\n    gl.enableVertexAttribArray(shader.attr_texCoord);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    gl.disableVertexAttribArray(shader.attr_position);\n    gl.disableVertexAttribArray(shader.attr_texCoord);\n    gl.bindTexture(gl.TEXTURE_2D, null);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.useProgram(null);\n  }\n\n  _getCameraShader(gl) {\n    if (this._shader) return this._shader;\n    let prog = gl.createProgram();\n    if (!prog) throw new Error(\"Unable to create program\");\n    let vertexShader = shader_1.compileShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);\n    let fragmentShader = shader_1.compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc);\n    gl.attachShader(prog, vertexShader);\n    gl.attachShader(prog, fragmentShader);\n    shader_1.linkProgram(gl, prog);\n    let unif_skinTexTransform = gl.getUniformLocation(prog, \"skinTexTransform\");\n    if (!unif_skinTexTransform) throw new Error(\"Unable to get uniform location skinTexTransform\");\n    let unif_skinSampler = gl.getUniformLocation(prog, \"skinSampler\");\n    if (!unif_skinSampler) throw new Error(\"Unable to get uniform location skinSampler\");\n    this._shader = {\n      prog,\n      unif_skinTexTransform,\n      unif_skinSampler,\n      attr_position: gl.getAttribLocation(prog, \"position\"),\n      attr_texCoord: gl.getAttribLocation(prog, \"texCoord\")\n    };\n    return this._shader;\n  }\n\n}\n\nexports.CameraDraw = CameraDraw;\nlet vertexShaderSrc = `\n#ifndef GL_ES\n#define highp\n#define mediump\n#define lowp\n#endif\n\nattribute vec4 position;\nattribute vec4 texCoord;\nvarying vec4 skinTexVarying;\nuniform mat4 skinTexTransform;\n\nvoid main()\n{\n    gl_Position = position;\n    skinTexVarying = skinTexTransform * texCoord;\n}`;\nlet fragmentShaderSrc = `\n#define highp mediump\n#ifdef GL_ES\n    // define default precision for float, vec, mat.\n    precision highp float;\n#else\n#define highp\n#define mediump\n#define lowp\n#endif\n\nvarying vec4 skinTexVarying;\nuniform lowp sampler2D skinSampler;\n\nvoid main()\n{\n    gl_FragColor = texture2DProj(skinSampler, skinTexVarying);\n}`;\n\nfunction cameraRotationForScreenOrientation() {\n  if (window.screen.orientation) {\n    switch (window.screen.orientation.type) {\n      case \"portrait-primary\":\n        return 270;\n\n      case \"landscape-secondary\":\n        return 180;\n\n      case \"portrait-secondary\":\n        return 90;\n\n      default:\n        return 0;\n    }\n  } else if (window.orientation !== undefined) {\n    switch (window.orientation) {\n      case 0:\n        return 270;\n\n      case 90:\n        return 0;\n\n      case 180:\n        return 90;\n\n      case -90:\n        return 180;\n    }\n  }\n\n  return 0;\n}\n\nfunction cameraFrameTextureMatrix(frameWidth, frameHeight, screenWidth, screenHeight, uvMatrix, mirror) {\n  let ret = gl_matrix_1.mat4.create();\n  let trans = gl_matrix_1.mat4.create(); // Translate to centre UV coords\n\n  gl_matrix_1.mat4.fromTranslation(trans, [-0.5, -0.5, 0]);\n  gl_matrix_1.mat4.multiply(ret, trans, ret);\n\n  if (mirror) {\n    gl_matrix_1.mat4.fromScaling(trans, [-1, 1, 1]);\n    gl_matrix_1.mat4.multiply(ret, trans, ret);\n  } // Apply rotation back into ZCV's landscape space\n\n\n  gl_matrix_1.mat4.fromRotation(trans, -1 * cameraRotationForScreenOrientation() * Math.PI / 180.0, [0, 0, 1]);\n  gl_matrix_1.mat4.multiply(ret, trans, ret); // Get our screenWidth and screenHeight into that same space\n\n  let vec = gl_matrix_1.vec3.create();\n  vec[0] = screenWidth;\n  vec[1] = screenHeight;\n  vec[2] = 0;\n  gl_matrix_1.vec3.transformMat4(vec, vec, trans);\n  let absScreenX = Math.abs(vec[0]);\n  let absScreenY = Math.abs(vec[1]); // Apply a flip since the texture is upside-down\n\n  gl_matrix_1.mat4.fromScaling(trans, [1, -1, 1]);\n  gl_matrix_1.mat4.multiply(ret, trans, ret); // Apply cropping\n\n  let screenAspect = absScreenX / absScreenY;\n  let frameAspect = frameWidth / frameHeight;\n\n  if (screenAspect > frameAspect) {\n    gl_matrix_1.mat4.fromScaling(trans, [1, frameAspect / screenAspect, 1]);\n  } else {\n    gl_matrix_1.mat4.fromScaling(trans, [screenAspect / frameAspect, 1, 1]);\n  }\n\n  gl_matrix_1.mat4.multiply(ret, trans, ret); // Translate back to UV coords\n\n  gl_matrix_1.mat4.fromTranslation(trans, [0.5, 0.5, 0]);\n  gl_matrix_1.mat4.multiply(ret, trans, ret); // Apply the camera frame's UV matrix\n\n  gl_matrix_1.mat4.multiply(ret, uvMatrix, ret);\n  return ret;\n}\n\nexports.cameraFrameTextureMatrix = cameraFrameTextureMatrix;","map":{"version":3,"sources":["/Users/StanleyWalker/Desktop/react-three-example-face-tracking-helmet-1/node_modules/@zappar/zappar-cv/lib/drawcamera.js"],"names":["Object","defineProperty","exports","value","cameraFrameTextureMatrix","CameraDraw","shader_1","require","gl_matrix_1","constructor","_gl","dispose","_vbo","deleteBuffer","undefined","_shader","deleteProgram","prog","_generate","gl","i","createBuffer","Error","vboData","Float32Array","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","drawCameraFrame","screenWidth","screenHeight","mirror","texture","disable","DEPTH_TEST","SCISSOR_TEST","CULL_FACE","BLEND","shader","_getCameraShader","vbo","activeTexture","TEXTURE0","useProgram","uniformMatrix4fv","unif_skinTexTransform","dataWidth","dataHeight","uvTransform","uniform1i","unif_skinSampler","bindTexture","TEXTURE_2D","vertexAttribPointer","attr_position","FLOAT","enableVertexAttribArray","attr_texCoord","drawArrays","TRIANGLES","disableVertexAttribArray","createProgram","vertexShader","compileShader","VERTEX_SHADER","vertexShaderSrc","fragmentShader","FRAGMENT_SHADER","fragmentShaderSrc","attachShader","linkProgram","getUniformLocation","getAttribLocation","cameraRotationForScreenOrientation","window","screen","orientation","type","frameWidth","frameHeight","uvMatrix","ret","mat4","create","trans","fromTranslation","multiply","fromScaling","fromRotation","Math","PI","vec","vec3","transformMat4","absScreenX","abs","absScreenY","screenAspect","frameAspect"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cameraFrameTextureMatrix = exports.CameraDraw = void 0;\nconst shader_1 = require(\"./shader\");\nconst gl_matrix_1 = require(\"gl-matrix\");\nclass CameraDraw {\n    constructor(_gl) {\n        this._gl = _gl;\n    }\n    dispose() {\n        if (this._vbo)\n            this._gl.deleteBuffer(this._vbo);\n        this._vbo = undefined;\n        if (this._shader)\n            this._gl.deleteProgram(this._shader.prog);\n        this._shader = undefined;\n    }\n    _generate(gl, i) {\n        if (this._vbo)\n            return this._vbo;\n        if (!this._vbo)\n            this._vbo = gl.createBuffer();\n        if (!this._vbo)\n            throw new Error(\"Unable to create buffer object\");\n        let vboData = new Float32Array([\n            -1, -1, 0, 0, 0,\n            -1, 1, 0, 0, 1,\n            1, -1, 0, 1, 0,\n            1, -1, 0, 1, 0,\n            -1, 1, 0, 0, 1,\n            1, 1, 0, 1, 1\n        ]);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._vbo);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vboData), gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        return this._vbo;\n    }\n    drawCameraFrame(screenWidth, screenHeight, i, mirror) {\n        if (!i.texture)\n            return;\n        let gl = this._gl;\n        gl.disable(gl.DEPTH_TEST);\n        gl.disable(gl.SCISSOR_TEST);\n        gl.disable(gl.CULL_FACE);\n        gl.disable(gl.BLEND);\n        let shader = this._getCameraShader(gl);\n        let vbo = this._generate(gl, i);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.useProgram(shader.prog);\n        gl.uniformMatrix4fv(shader.unif_skinTexTransform, false, cameraFrameTextureMatrix(i.dataWidth, i.dataHeight, screenWidth, screenHeight, i.uvTransform, mirror));\n        gl.uniform1i(shader.unif_skinSampler, 0);\n        gl.bindTexture(gl.TEXTURE_2D, i.texture);\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);\n        gl.vertexAttribPointer(shader.attr_position, 3, gl.FLOAT, false, 5 * 4, 0);\n        gl.enableVertexAttribArray(shader.attr_position);\n        gl.vertexAttribPointer(shader.attr_texCoord, 2, gl.FLOAT, false, 5 * 4, 3 * 4);\n        gl.enableVertexAttribArray(shader.attr_texCoord);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n        gl.disableVertexAttribArray(shader.attr_position);\n        gl.disableVertexAttribArray(shader.attr_texCoord);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        gl.useProgram(null);\n    }\n    _getCameraShader(gl) {\n        if (this._shader)\n            return this._shader;\n        let prog = gl.createProgram();\n        if (!prog)\n            throw new Error(\"Unable to create program\");\n        let vertexShader = shader_1.compileShader(gl, gl.VERTEX_SHADER, vertexShaderSrc);\n        let fragmentShader = shader_1.compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc);\n        gl.attachShader(prog, vertexShader);\n        gl.attachShader(prog, fragmentShader);\n        shader_1.linkProgram(gl, prog);\n        let unif_skinTexTransform = gl.getUniformLocation(prog, \"skinTexTransform\");\n        if (!unif_skinTexTransform)\n            throw new Error(\"Unable to get uniform location skinTexTransform\");\n        let unif_skinSampler = gl.getUniformLocation(prog, \"skinSampler\");\n        if (!unif_skinSampler)\n            throw new Error(\"Unable to get uniform location skinSampler\");\n        this._shader = {\n            prog,\n            unif_skinTexTransform,\n            unif_skinSampler,\n            attr_position: gl.getAttribLocation(prog, \"position\"),\n            attr_texCoord: gl.getAttribLocation(prog, \"texCoord\")\n        };\n        return this._shader;\n    }\n}\nexports.CameraDraw = CameraDraw;\nlet vertexShaderSrc = `\n#ifndef GL_ES\n#define highp\n#define mediump\n#define lowp\n#endif\n\nattribute vec4 position;\nattribute vec4 texCoord;\nvarying vec4 skinTexVarying;\nuniform mat4 skinTexTransform;\n\nvoid main()\n{\n    gl_Position = position;\n    skinTexVarying = skinTexTransform * texCoord;\n}`;\nlet fragmentShaderSrc = `\n#define highp mediump\n#ifdef GL_ES\n    // define default precision for float, vec, mat.\n    precision highp float;\n#else\n#define highp\n#define mediump\n#define lowp\n#endif\n\nvarying vec4 skinTexVarying;\nuniform lowp sampler2D skinSampler;\n\nvoid main()\n{\n    gl_FragColor = texture2DProj(skinSampler, skinTexVarying);\n}`;\nfunction cameraRotationForScreenOrientation() {\n    if (window.screen.orientation) {\n        switch (window.screen.orientation.type) {\n            case \"portrait-primary\":\n                return 270;\n            case \"landscape-secondary\":\n                return 180;\n            case \"portrait-secondary\":\n                return 90;\n            default:\n                return 0;\n        }\n    }\n    else if (window.orientation !== undefined) {\n        switch (window.orientation) {\n            case 0: return 270;\n            case 90: return 0;\n            case 180: return 90;\n            case -90: return 180;\n        }\n    }\n    return 0;\n}\nfunction cameraFrameTextureMatrix(frameWidth, frameHeight, screenWidth, screenHeight, uvMatrix, mirror) {\n    let ret = gl_matrix_1.mat4.create();\n    let trans = gl_matrix_1.mat4.create();\n    // Translate to centre UV coords\n    gl_matrix_1.mat4.fromTranslation(trans, [-0.5, -0.5, 0]);\n    gl_matrix_1.mat4.multiply(ret, trans, ret);\n    if (mirror) {\n        gl_matrix_1.mat4.fromScaling(trans, [-1, 1, 1]);\n        gl_matrix_1.mat4.multiply(ret, trans, ret);\n    }\n    // Apply rotation back into ZCV's landscape space\n    gl_matrix_1.mat4.fromRotation(trans, -1 * cameraRotationForScreenOrientation() * Math.PI / 180.0, [0, 0, 1]);\n    gl_matrix_1.mat4.multiply(ret, trans, ret);\n    // Get our screenWidth and screenHeight into that same space\n    let vec = gl_matrix_1.vec3.create();\n    vec[0] = screenWidth;\n    vec[1] = screenHeight;\n    vec[2] = 0;\n    gl_matrix_1.vec3.transformMat4(vec, vec, trans);\n    let absScreenX = Math.abs(vec[0]);\n    let absScreenY = Math.abs(vec[1]);\n    // Apply a flip since the texture is upside-down\n    gl_matrix_1.mat4.fromScaling(trans, [1, -1, 1]);\n    gl_matrix_1.mat4.multiply(ret, trans, ret);\n    // Apply cropping\n    let screenAspect = absScreenX / absScreenY;\n    let frameAspect = frameWidth / frameHeight;\n    if (screenAspect > frameAspect) {\n        gl_matrix_1.mat4.fromScaling(trans, [1, frameAspect / screenAspect, 1]);\n    }\n    else {\n        gl_matrix_1.mat4.fromScaling(trans, [screenAspect / frameAspect, 1, 1]);\n    }\n    gl_matrix_1.mat4.multiply(ret, trans, ret);\n    // Translate back to UV coords\n    gl_matrix_1.mat4.fromTranslation(trans, [0.5, 0.5, 0]);\n    gl_matrix_1.mat4.multiply(ret, trans, ret);\n    // Apply the camera frame's UV matrix\n    gl_matrix_1.mat4.multiply(ret, uvMatrix, ret);\n    return ret;\n}\nexports.cameraFrameTextureMatrix = cameraFrameTextureMatrix;\n"]},"metadata":{},"sourceType":"script"}