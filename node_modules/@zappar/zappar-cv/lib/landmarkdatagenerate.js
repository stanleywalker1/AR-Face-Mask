"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateDataCPP = exports.generateDataJSON = void 0;
const facemesh_1 = require("./facemesh");
const zappar_1 = require("./gen/zappar");
let vertexIndexByName = new Map([
    [zappar_1.face_landmark_name_t.EAR_LEFT, 888],
    [zappar_1.face_landmark_name_t.EAR_RIGHT, 467],
    [zappar_1.face_landmark_name_t.EYE_LEFT, [1076, 1062]],
    [zappar_1.face_landmark_name_t.EYE_RIGHT, [1094, 1108]],
    [zappar_1.face_landmark_name_t.NOSE_BRIDGE, 36],
    [zappar_1.face_landmark_name_t.NOSE_BASE, 3],
    [zappar_1.face_landmark_name_t.NOSE_TIP, 8],
    [zappar_1.face_landmark_name_t.LIP_TOP, 24],
    [zappar_1.face_landmark_name_t.LIP_BOTTOM, 25],
    [zappar_1.face_landmark_name_t.MOUTH_CENTER, [24, 25]],
    [zappar_1.face_landmark_name_t.CHIN, 1049],
    [zappar_1.face_landmark_name_t.EYEBROW_LEFT, 657],
    [zappar_1.face_landmark_name_t.EYEBROW_RIGHT, 210],
]);
function generateDataJSON() {
    return __awaiter(this, void 0, void 0, function* () {
        let mesh = new facemesh_1.FaceMesh();
        let url = require("file-loader!./face_mesh_face_model.zbin").default;
        let req = yield fetch(url);
        mesh.loadFromMemory(yield req.arrayBuffer(), false, false, false, false);
        let names = new Set([zappar_1.face_landmark_name_t.EYE_LEFT, zappar_1.face_landmark_name_t.EYE_RIGHT, zappar_1.face_landmark_name_t.EAR_LEFT, zappar_1.face_landmark_name_t.EAR_RIGHT, zappar_1.face_landmark_name_t.NOSE_BRIDGE, zappar_1.face_landmark_name_t.NOSE_TIP, zappar_1.face_landmark_name_t.NOSE_BASE, zappar_1.face_landmark_name_t.LIP_TOP, zappar_1.face_landmark_name_t.LIP_BOTTOM, zappar_1.face_landmark_name_t.MOUTH_CENTER, zappar_1.face_landmark_name_t.CHIN, zappar_1.face_landmark_name_t.EYEBROW_LEFT, zappar_1.face_landmark_name_t.EYEBROW_RIGHT]);
        let data = {};
        for (let n of names) {
            let indices = vertexIndexByName.get(n);
            if (!indices)
                throw new Error("NO VERTEX FOR " + n.toString());
            if (Array.isArray(indices)) {
                let arr = [];
                for (let i of indices) {
                    arr.push(mesh.getLandmarkDataForVertex(i));
                }
                data[n] = arr;
            }
            else {
                data[n] = mesh.getLandmarkDataForVertex(indices);
            }
        }
        return JSON.stringify(data, (key, val) => {
            return val.toFixed ? Number(val.toFixed(4)) : val;
        });
    });
}
exports.generateDataJSON = generateDataJSON;
function arrayAsCPPLiteral(a) {
    return `{ ${a.join(", ")} }`;
}
function generateDataCPP() {
    return __awaiter(this, void 0, void 0, function* () {
        let mesh = new facemesh_1.FaceMesh();
        let url = require("file-loader!./face_mesh_face_model.zbin").default;
        let req = yield fetch(url);
        mesh.loadFromMemory(yield req.arrayBuffer(), false, false, false, false);
        let names = [zappar_1.face_landmark_name_t.EYE_LEFT, zappar_1.face_landmark_name_t.EYE_RIGHT, zappar_1.face_landmark_name_t.EAR_LEFT, zappar_1.face_landmark_name_t.EAR_RIGHT, zappar_1.face_landmark_name_t.NOSE_BRIDGE, zappar_1.face_landmark_name_t.NOSE_TIP, zappar_1.face_landmark_name_t.NOSE_BASE, zappar_1.face_landmark_name_t.LIP_TOP, zappar_1.face_landmark_name_t.LIP_BOTTOM, zappar_1.face_landmark_name_t.MOUTH_CENTER, zappar_1.face_landmark_name_t.CHIN, zappar_1.face_landmark_name_t.EYEBROW_LEFT, zappar_1.face_landmark_name_t.EYEBROW_RIGHT];
        let output = "std::vector<std::vector<std::vector<float> > > _zappar_landmark_means = {\n";
        output += names.map(val => {
            let indices = vertexIndexByName.get(val);
            if (!indices)
                throw new Error("NO VERTEX FOR " + val.toString());
            if (!Array.isArray(indices))
                indices = [indices];
            return arrayAsCPPLiteral(indices.map(val => arrayAsCPPLiteral(mesh.getLandmarkDataForVertex(val).mean)));
        }).join(",\n");
        output += "};\n";
        output += "std::vector<std::vector<std::vector<float> > > _zappar_landmark_identities = {\n";
        output += names.map(val => {
            let indices = vertexIndexByName.get(val);
            if (!indices)
                throw new Error("NO VERTEX FOR " + val.toString());
            if (!Array.isArray(indices))
                indices = [indices];
            return arrayAsCPPLiteral(indices.map(val => arrayAsCPPLiteral(mesh.getLandmarkDataForVertex(val).identity)));
        }).join(",\n");
        output += "};\n";
        output += "std::vector<std::vector<std::vector<float> > > _zappar_landmark_expressions = {\n";
        output += names.map(val => {
            let indices = vertexIndexByName.get(val);
            if (!indices)
                throw new Error("NO VERTEX FOR " + val.toString());
            if (!Array.isArray(indices))
                indices = [indices];
            return arrayAsCPPLiteral(indices.map(val => arrayAsCPPLiteral(mesh.getLandmarkDataForVertex(val).expression)));
        }).join(",\n");
        output += "};\n";
        return output;
    });
}
exports.generateDataCPP = generateDataCPP;
