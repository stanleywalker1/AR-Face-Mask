"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyScreenCounterRotation = exports.Pipeline = void 0;
const drawcamera_1 = require("./drawcamera");
const gl_matrix_1 = require("gl-matrix");
const cameramodel_1 = require("./cameramodel");
const drawface_1 = require("./drawface");
const drawfaceproject_1 = require("./drawfaceproject");
const drawplane_1 = require("./drawplane");
const event_1 = require("./event");
const loglevel_1 = require("./loglevel");
let byId = new Map();
class Pipeline {
    constructor(_client, _impl, _mgr) {
        this._client = _client;
        this._impl = _impl;
        this._mgr = _mgr;
        this.pendingMessages = [];
        this.cameraTokens = new Map();
        this.nextCameraToken = 1;
        this.tokensInFlight = 0;
        this.videoTextures = [];
        this.cameraPixelArrays = [];
        this.onGLContextReset = new event_1.Event();
    }
    static create(client, mgr) {
        let ret = client.pipeline_create();
        byId.set(ret, new Pipeline(client, ret, mgr));
        return ret;
    }
    static get(p) {
        return byId.get(p);
    }
    frameUpdate(client) {
        for (let msg of this.pendingMessages) {
            client.processMessages(msg);
            this._mgr.postOutgoingMessage({
                t: "buf",
                p: this._impl,
                d: msg
            }, [msg]);
        }
        this.pendingMessages = [];
        let currentToken = this._client.pipeline_camera_frame_user_data(this._impl);
        if (!currentToken)
            return;
        for (let t of this.cameraTokens) {
            if (t[0] < currentToken) {
                if (t[1].texture)
                    this.videoTextures.push(t[1].texture);
                this.cameraTokens.delete(t[0]);
            }
        }
    }
    cameraTokenReturn(tokenId, pixelArray) {
        this.cameraPixelArrays.push(pixelArray);
        this.tokensInFlight--;
    }
    getVideoTexture() {
        return this.videoTextures.pop();
    }
    destroy() {
        this._client.pipeline_destroy(this._impl);
        byId.delete(this._impl);
    }
    getCurrentCameraInfo() {
        let currentToken = this._client.pipeline_camera_frame_user_data(this._impl);
        if (!currentToken)
            return undefined;
        return this.cameraTokens.get(currentToken);
    }
    cameraFrameDrawGL(screenWidth, screenHeight, mirror) {
        if (!this.glContext)
            return;
        let token = this.getCurrentCameraInfo();
        if (!token)
            return;
        if (!this._cameraDraw)
            this._cameraDraw = new drawcamera_1.CameraDraw(this.glContext);
        this._cameraDraw.drawCameraFrame(screenWidth, screenHeight, token, mirror === true);
    }
    glContextLost() {
        if (this._cameraDraw)
            this._cameraDraw.dispose();
        if (this._faceDraw)
            this._faceDraw.dispose();
        if (this._faceProjectDraw)
            this._faceProjectDraw.dispose();
        delete this._cameraDraw;
        delete this._faceDraw;
        delete this._faceProjectDraw;
        drawplane_1.disposeDrawPlane();
        this.onGLContextReset.emit();
        for (let tex of this.videoTextures) {
            if (this.glContext)
                this.glContext.deleteTexture(tex);
        }
        this.videoTextures = [];
        for (let info of this.cameraTokens) {
            if (this.glContext && info[1].texture)
                this.glContext.deleteTexture(info[1].texture);
            info[1].texture = undefined;
        }
        this.glContext = undefined;
    }
    glContextSet(gl, texturePool) {
        this.glContextLost();
        this.glContext = gl;
        texturePool = texturePool || [];
        for (let i = 0; i < 4; i++) {
            let tex = texturePool[i] || gl.createTexture();
            if (tex) {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                this.videoTextures.push(tex);
            }
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
    drawFace(projectionMatrix, cameraMatrix, targetMatrix, o) {
        if (!this.glContext)
            return;
        if (!this._faceDraw)
            this._faceDraw = new drawface_1.FaceDraw(this.glContext);
        let mat = gl_matrix_1.mat4.create();
        gl_matrix_1.mat4.multiply(mat, projectionMatrix, cameraMatrix);
        gl_matrix_1.mat4.multiply(mat, mat, targetMatrix);
        this._faceDraw.drawFace(mat, o);
    }
    drawFaceProject(matrix, vertices, uvMatrix, uvs, indices, texture) {
        if (!this.glContext)
            return;
        if (!this._faceProjectDraw)
            this._faceProjectDraw = new drawfaceproject_1.FaceDrawProject(this.glContext);
        this._faceProjectDraw.drawFace(matrix, vertices, uvMatrix, uvs, indices, texture);
    }
    cameraFrameTexture() {
        var _a;
        return (_a = this.getCurrentCameraInfo()) === null || _a === void 0 ? void 0 : _a.texture;
    }
    cameraFrameTextureMatrix(sw, sh, mirror) {
        let info = this.getCurrentCameraInfo();
        if (!info)
            return gl_matrix_1.mat4.create();
        return drawcamera_1.cameraFrameTextureMatrix(info.dataWidth, info.dataHeight, sw, sh, info.uvTransform, mirror);
    }
    cameraFrameUserFacing() {
        var _a;
        return ((_a = this.getCurrentCameraInfo()) === null || _a === void 0 ? void 0 : _a.userFacing) || false;
    }
    cameraPoseWithAttitude(mirror) {
        let res = applyScreenCounterRotation(this.getCurrentCameraInfo(), this._client.pipeline_camera_frame_camera_attitude(this._impl));
        if (mirror) {
            let scale = gl_matrix_1.mat4.create();
            gl_matrix_1.mat4.fromScaling(scale, [-1, 1, 1]);
            gl_matrix_1.mat4.multiply(res, scale, res);
            gl_matrix_1.mat4.multiply(res, res, scale);
        }
        gl_matrix_1.mat4.invert(res, res);
        return res;
    }
    processGL() {
        if (!this.glContext) {
            loglevel_1.zcerr("no GL context for camera frames - please call pipeline_gl_context_set");
            return;
        }
        if (!this.currentCameraSource)
            return;
        if (this.tokensInFlight > 0) {
            this.currentCameraSource.getFrame(true);
            return;
        }
        let info = this.currentCameraSource.getFrame(false);
        if (!info)
            return;
        let tokenId = this.nextCameraToken++;
        this.cameraTokens.set(tokenId, info);
        let msg = {
            d: info.data,
            p: this._impl,
            width: info.dataWidth,
            height: info.dataHeight,
            token: tokenId,
            userFacing: info.userFacing,
            t: "cameraFrameC2S"
        };
        this.tokensInFlight++;
        this._mgr.postOutgoingMessage(msg, [info.data]);
    }
    motionAccelerometerSubmit(timestamp, x, y, z) {
        this._client.pipeline_motion_accelerometer_submit(this._impl, timestamp, x, y, z);
    }
    motionRotationRateSubmit(timestamp, x, y, z) {
        this._client.pipeline_motion_rotation_rate_submit(this._impl, timestamp, x, y, z);
    }
    motionAttitudeSubmit(timestamp, x, y, z) {
        this._client.pipeline_motion_attitude_submit(this._impl, timestamp, x, y, z);
    }
}
exports.Pipeline = Pipeline;
function applyScreenCounterRotation(info, inp) {
    let userFacing = false;
    userFacing = info ? info.userFacing : false;
    let mult = gl_matrix_1.mat4.create();
    gl_matrix_1.mat4.fromRotation(mult, cameramodel_1.cameraRotationForScreenOrientation(userFacing) * Math.PI / 180.0, [0, 0, 1]);
    gl_matrix_1.mat4.multiply(mult, mult, inp);
    return mult;
}
exports.applyScreenCounterRotation = applyScreenCounterRotation;
