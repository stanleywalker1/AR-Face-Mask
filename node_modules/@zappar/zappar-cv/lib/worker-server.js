"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.launchWorkerServer = exports.messageManager = void 0;
const ZNM = require("./zcv");
const zappar_cwrap_1 = require("./gen/zappar-cwrap");
const zappar_server_1 = require("./gen/zappar-server");
const messages_1 = require("./messages");
const gl_matrix_1 = require("gl-matrix");
exports.messageManager = new messages_1.MsgManager();
function launchWorkerServer(wasmUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        let mod = ZNM.default({
            locateFile: (path, prefix) => {
                if (path.endsWith("zcv.wasm")) {
                    return wasmUrl;
                }
                return prefix + path;
            },
            onRuntimeInitialized: () => {
                let r = zappar_cwrap_1.getRuntimeObject(mod);
                let server = new zappar_server_1.zappar_server(r, (pipelineId, ab) => {
                    exports.messageManager.postOutgoingMessage({
                        p: pipelineId,
                        t: "zappar",
                        d: ab
                    }, [ab]);
                });
                exports.messageManager.postOutgoingMessage("loaded", []);
                exports.messageManager.onIncomingMessage.bind((msg) => {
                    var _a;
                    switch (msg.t) {
                        case "zappar":
                            server.processBuffer(msg.d);
                            exports.messageManager.postOutgoingMessage({ t: "buf", d: msg.d }, [msg.d]);
                            break;
                        case "buf":
                            (_a = server.serializersByPipelineId.get(msg.p)) === null || _a === void 0 ? void 0 : _a.bufferReturn(msg.d);
                            break;
                        case "cameraFrameC2S":
                            let msgt = msg;
                            // PROCESS DATA
                            let cameraToDeviceTransform = gl_matrix_1.mat4.create();
                            if (msgt.userFacing) {
                                gl_matrix_1.mat4.fromScaling(cameraToDeviceTransform, [-1, 1, -1]);
                            }
                            let pipeline = server._pipeline_by_instance.get(msgt.p);
                            if (pipeline) {
                                r.pipeline_camera_frame_submit(pipeline, msgt.d, msgt.width, msgt.height, msgt.token, cameraToDeviceTransform);
                                r.pipeline_frame_update(pipeline);
                                server.exploreState();
                            }
                            let ret = {
                                token: msgt.token,
                                d: msgt.d,
                                p: msgt.p,
                                t: "cameraFrameRecycleS2C"
                            };
                            exports.messageManager.postOutgoingMessage(ret, [msgt.d]);
                            break;
                    }
                });
            }
        });
    });
}
exports.launchWorkerServer = launchWorkerServer;
;
