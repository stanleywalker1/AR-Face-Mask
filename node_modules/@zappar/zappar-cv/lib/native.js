"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initialize = void 0;
const zappar_client_1 = require("./gen/zappar-client");
const drawplane_1 = require("./drawplane");
const cameramodel_1 = require("./cameramodel");
const gl_matrix_1 = require("gl-matrix");
const worker_client_1 = require("./worker-client");
const permission_1 = require("./permission");
const facemesh_1 = require("./facemesh");
const pipeline_1 = require("./pipeline");
const camera_source_1 = require("./camera-source");
const html_element_source_1 = require("./html-element-source");
const facelandmark_1 = require("./facelandmark");
const compatibility_1 = require("./compatibility");
const loglevel_1 = require("./loglevel");
let client;
function initialize() {
    if (client)
        return client;
    let loaded = false;
    worker_client_1.launchWorker().then(() => {
        loglevel_1.zcout("Fully loaded");
        loaded = true;
    });
    let c = new zappar_client_1.zappar_client(ab => {
        worker_client_1.messageManager.postOutgoingMessage({
            t: "zappar",
            d: ab
        }, [ab]);
    });
    if (window.location.hostname.toLowerCase().indexOf(".zappar.io") > 0) {
        let pathParts = window.location.pathname.split("/");
        if (pathParts.length > 1 && pathParts[1].length > 0)
            c.impl.analytics_project_id_set(".wiz" + pathParts[1]);
    }
    worker_client_1.messageManager.onIncomingMessage.bind(msg => {
        var _a, _b;
        switch (msg.t) {
            case "zappar":
                (_a = pipeline_1.Pipeline.get(msg.p)) === null || _a === void 0 ? void 0 : _a.pendingMessages.push(msg.d);
                break;
            case "buf":
                c.serializer.bufferReturn(msg.d);
                break;
            case "cameraFrameRecycleS2C":
                let msgt = msg;
                (_b = pipeline_1.Pipeline.get(msgt.p)) === null || _b === void 0 ? void 0 : _b.cameraTokenReturn(msgt.token, msgt.d);
                break;
            case "licerr": {
                let div = document.createElement("div");
                div.innerHTML = "Visit <a href='https://docs.zap.works/universal-ar/licensing/' style='color: white;'>our licensing page</a> to find out about hosting on your own domain.";
                div.style.position = "absolute";
                div.style.bottom = "20px";
                div.style.width = "80%";
                div.style.backgroundColor = "black";
                div.style.color = "white";
                div.style.borderRadius = "10px";
                div.style.padding = "10px";
                div.style.fontFamily = "sans-serif";
                div.style.textAlign = "center";
                div.style.left = "10%";
                div.style.zIndex = Number.MAX_SAFE_INTEGER.toString();
                let span = document.createElement("span");
                span.innerText = " (30)";
                div.append(span);
                let indx = 30;
                setInterval(function () {
                    indx--;
                    if (indx >= 0)
                        span.innerText = " (" + indx.toString() + ")";
                }, 1000);
                document.body.append(div);
            }
        }
    });
    client = Object.assign(Object.assign({}, c.impl), { loaded: () => loaded, camera_default_device_id: userFacing => userFacing ? camera_source_1.CameraSource.USER_DEFAULT_DEVICE_ID : camera_source_1.CameraSource.DEFAULT_DEVICE_ID, camera_source_create: (p, deviceId) => camera_source_1.CameraSource.create(p, deviceId), camera_source_destroy: cam => { var _a; return (_a = camera_source_1.CameraSource.get(cam)) === null || _a === void 0 ? void 0 : _a.destroy(); }, camera_source_pause: cam => { var _a; return (_a = camera_source_1.CameraSource.get(cam)) === null || _a === void 0 ? void 0 : _a.pause(); }, camera_source_start: cam => { var _a; return (_a = camera_source_1.CameraSource.get(cam)) === null || _a === void 0 ? void 0 : _a.start(); }, pipeline_create: () => pipeline_1.Pipeline.create(c.impl, worker_client_1.messageManager), pipeline_frame_update: (p) => { var _a; return (_a = pipeline_1.Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.frameUpdate(c); }, pipeline_camera_frame_draw_gl: (pipeline, screenWidth, screenHeight, mirror) => {
            var _a;
            (_a = pipeline_1.Pipeline.get(pipeline)) === null || _a === void 0 ? void 0 : _a.cameraFrameDrawGL(screenWidth, screenHeight, mirror);
        }, draw_plane: (gl, projectionMatrix, cameraMatrix, targetMatrix, texture) => {
            drawplane_1.drawPlane(gl, projectionMatrix, cameraMatrix, targetMatrix, texture);
        }, pipeline_draw_face: (p, projectionMatrix, cameraMatrix, targetMatrix, o) => {
            var _a;
            let obj = facemesh_1.getFaceMesh(o);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call draw_face on a destroyed zappar_face_mesh_t");
                return new Uint16Array();
            }
            (_a = pipeline_1.Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.drawFace(projectionMatrix, cameraMatrix, targetMatrix, obj);
        }, pipeline_draw_face_project: (p, matrix, vertices, uvMatrix, uvs, indices, texture) => {
            var _a;
            (_a = pipeline_1.Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.drawFaceProject(matrix, vertices, uvMatrix, uvs, indices, texture);
        }, projection_matrix_from_camera_model: cameramodel_1.projectionMatrix, projection_matrix_from_camera_model_ext: cameramodel_1.projectionMatrix, pipeline_process_gl: p => { var _a; return (_a = pipeline_1.Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.processGL(); }, pipeline_gl_context_set: (p, gl, texturePool) => { var _a; return (_a = pipeline_1.Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.glContextSet(gl, texturePool); }, pipeline_gl_context_lost: (p) => { var _a; return (_a = pipeline_1.Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.glContextLost(); }, pipeline_camera_frame_upload_gl: () => { }, pipeline_camera_frame_texture_gl: p => { var _a; return (_a = pipeline_1.Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.cameraFrameTexture(); }, pipeline_camera_frame_texture_matrix: (p, sw, sh, mirror) => { var _a; return ((_a = pipeline_1.Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.cameraFrameTextureMatrix(sw, sh, mirror)) || gl_matrix_1.mat4.create(); }, pipeline_camera_frame_user_facing: p => { var _a; return ((_a = pipeline_1.Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.cameraFrameUserFacing()) || false; }, pipeline_camera_pose_default: () => gl_matrix_1.mat4.create(), pipeline_camera_pose_with_attitude: (p, mirror) => { var _a; return ((_a = pipeline_1.Pipeline.get(p)) === null || _a === void 0 ? void 0 : _a.cameraPoseWithAttitude(mirror)) || gl_matrix_1.mat4.create(); }, pipeline_camera_pose_with_origin: (p, o) => { let res = gl_matrix_1.mat4.create(); gl_matrix_1.mat4.invert(res, o); return res; }, instant_world_tracker_anchor_pose_camera_relative: (o, mirror) => {
            let res = pipeline_1.applyScreenCounterRotation(undefined, c.impl.instant_world_tracker_anchor_pose_raw(o));
            if (mirror) {
                let scale = gl_matrix_1.mat4.create();
                gl_matrix_1.mat4.fromScaling(scale, [-1, 1, 1]);
                gl_matrix_1.mat4.multiply(res, scale, res);
                gl_matrix_1.mat4.multiply(res, res, scale);
            }
            return res;
        }, instant_world_tracker_anchor_pose: (o, cameraPose, mirror) => {
            let res = pipeline_1.applyScreenCounterRotation(undefined, c.impl.instant_world_tracker_anchor_pose_raw(o));
            if (mirror) {
                let scale = gl_matrix_1.mat4.create();
                gl_matrix_1.mat4.fromScaling(scale, [-1, 1, 1]);
                gl_matrix_1.mat4.multiply(res, scale, res);
                gl_matrix_1.mat4.multiply(res, res, scale);
            }
            gl_matrix_1.mat4.multiply(res, cameraPose, res);
            return res;
        }, image_tracker_anchor_pose_camera_relative: (o, indx, mirror) => {
            let res = pipeline_1.applyScreenCounterRotation(undefined, c.impl.image_tracker_anchor_pose_raw(o, indx));
            if (mirror) {
                let scale = gl_matrix_1.mat4.create();
                gl_matrix_1.mat4.fromScaling(scale, [-1, 1, 1]);
                gl_matrix_1.mat4.multiply(res, scale, res);
                gl_matrix_1.mat4.multiply(res, res, scale);
            }
            return res;
        }, image_tracker_anchor_pose: (o, indx, cameraPose, mirror) => {
            let res = pipeline_1.applyScreenCounterRotation(undefined, c.impl.image_tracker_anchor_pose_raw(o, indx));
            if (mirror) {
                let scale = gl_matrix_1.mat4.create();
                gl_matrix_1.mat4.fromScaling(scale, [-1, 1, 1]);
                gl_matrix_1.mat4.multiply(res, scale, res);
                gl_matrix_1.mat4.multiply(res, res, scale);
            }
            gl_matrix_1.mat4.multiply(res, cameraPose, res);
            return res;
        }, face_tracker_anchor_pose_camera_relative: (o, indx, mirror) => {
            let res = pipeline_1.applyScreenCounterRotation(undefined, c.impl.face_tracker_anchor_pose_raw(o, indx));
            if (mirror) {
                let scale = gl_matrix_1.mat4.create();
                gl_matrix_1.mat4.fromScaling(scale, [-1, 1, 1]);
                gl_matrix_1.mat4.multiply(res, scale, res);
                gl_matrix_1.mat4.multiply(res, res, scale);
            }
            return res;
        }, face_tracker_anchor_pose: (o, indx, cameraPose, mirror) => {
            let res = pipeline_1.applyScreenCounterRotation(undefined, c.impl.face_tracker_anchor_pose_raw(o, indx));
            if (mirror) {
                let scale = gl_matrix_1.mat4.create();
                gl_matrix_1.mat4.fromScaling(scale, [-1, 1, 1]);
                gl_matrix_1.mat4.multiply(res, scale, res);
                gl_matrix_1.mat4.multiply(res, res, scale);
            }
            gl_matrix_1.mat4.multiply(res, cameraPose, res);
            return res;
        }, face_tracker_model_load_default: (o) => __awaiter(this, void 0, void 0, function* () {
            yield loadDefaultFaceModel(o);
        }), face_mesh_create: () => {
            return facemesh_1.createFaceMesh();
        }, face_mesh_destroy: (m) => {
            facemesh_1.destroyFaceMesh(m);
        }, face_mesh_indices: (m) => {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_indices on a destroyed zappar_face_mesh_t");
                return new Uint16Array();
            }
            return obj.getIndices();
        }, face_mesh_indices_size: (m) => {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_indices_size on a destroyed zappar_face_mesh_t");
                return 0;
            }
            return obj.getIndices().length;
        }, face_mesh_uvs: (m) => {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_uvs on a destroyed zappar_face_mesh_t");
                return new Float32Array();
            }
            return obj.getUVs();
        }, face_mesh_uvs_size: (m) => {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_uvs_size on a destroyed zappar_face_mesh_t");
                return 0;
            }
            return obj.getUVs().length;
        }, face_mesh_vertices: (m) => {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_vertices on a destroyed zappar_face_mesh_t");
                return new Float32Array();
            }
            return obj.getVertices();
        }, face_mesh_vertices_size: (m) => {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_vertices_size on a destroyed zappar_face_mesh_t");
                return 0;
            }
            return obj.getVertices().length;
        }, face_mesh_normals: (m) => {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_normals on a destroyed zappar_face_mesh_t");
                return new Float32Array();
            }
            return obj.getNormals();
        }, face_mesh_normals_size: (m) => {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_normals_size on a destroyed zappar_face_mesh_t");
                return 0;
            }
            return obj.getNormals().length;
        }, face_mesh_load_from_memory: (m, ab, fillMouth, fillEyeL, fillEyeR, fillNeck) => {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_load_from_memory on a destroyed zappar_face_mesh_t");
                return;
            }
            obj.loadFromMemory(ab, fillMouth, fillEyeL, fillEyeR, fillNeck);
        }, face_mesh_update: (m, identity, expression, mirrored) => {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_update on a destroyed zappar_face_mesh_t");
                return;
            }
            obj.update(identity, expression, mirrored);
        }, face_mesh_load_default: (m) => __awaiter(this, void 0, void 0, function* () {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_load_default on a destroyed zappar_face_mesh_t");
                return;
            }
            let url = require("file-loader!./face_mesh_face_model.zbin");
            if (url.default !== undefined)
                url = url.default;
            let req = yield fetch(url);
            obj.loadFromMemory(yield req.arrayBuffer(), false, false, false, false);
        }), face_mesh_load_default_face: (m, fillMouth, fillEyeL, fillEyeR) => __awaiter(this, void 0, void 0, function* () {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_load_default_face on a destroyed zappar_face_mesh_t");
                return;
            }
            let url = require("file-loader!./face_mesh_face_model.zbin");
            if (url.default !== undefined)
                url = url.default;
            let req = yield fetch(url);
            obj.loadFromMemory(yield req.arrayBuffer(), fillMouth, fillEyeL, fillEyeR, false);
        }), face_mesh_load_default_full_head_simplified: (m, fillMouth, fillEyeL, fillEyeR, fillNeck) => __awaiter(this, void 0, void 0, function* () {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_load_default_full_head_simplified on a destroyed zappar_face_mesh_t");
                return;
            }
            let url = require("file-loader!./face_mesh_full_head_simplified_model.zbin");
            if (url.default !== undefined)
                url = url.default;
            let req = yield fetch(url);
            obj.loadFromMemory(yield req.arrayBuffer(), fillMouth, fillEyeL, fillEyeR, fillNeck);
        }), face_mesh_loaded_version: (m) => {
            let obj = facemesh_1.getFaceMesh(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_mesh_load_default on a destroyed zappar_face_mesh_t");
                return -1;
            }
            return obj.getModelVersion();
        }, face_landmark_create: (n) => {
            return facelandmark_1.createFaceLandmark(n);
        }, face_landmark_destroy: (m) => {
            facelandmark_1.destroyFaceLandmark(m);
        }, face_landmark_update: (m, identity, expression, mirrored) => {
            let obj = facelandmark_1.getFaceLandmark(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_landmark_update on a destroyed zappar_face_landmark_t");
                return;
            }
            obj.update(identity, expression, mirrored);
        }, face_landmark_anchor_pose: (m) => {
            let obj = facelandmark_1.getFaceLandmark(m);
            if (!obj) {
                loglevel_1.zcwarn("attempting to call face_landmark_anchor_pose on a destroyed zappar_face_landmark_t");
                return gl_matrix_1.mat4.create();
            }
            return obj.anchor_pose;
        }, html_element_source_create: (pipeline, elm) => html_element_source_1.HTMLElementSource.createVideoElementSource(pipeline, elm), html_element_source_start: o => { var _a; return (_a = html_element_source_1.HTMLElementSource.getVideoElementSource(o)) === null || _a === void 0 ? void 0 : _a.start(); }, html_element_source_pause: o => { var _a; return (_a = html_element_source_1.HTMLElementSource.getVideoElementSource(o)) === null || _a === void 0 ? void 0 : _a.pause(); }, html_element_source_destroy: o => { var _a; return (_a = html_element_source_1.HTMLElementSource.getVideoElementSource(o)) === null || _a === void 0 ? void 0 : _a.destroy(); }, permission_granted_all: permission_1.permissionGrantedAll, permission_granted_camera: permission_1.permissionGrantedCamera, permission_granted_motion: permission_1.permissionGrantedMotion, permission_denied_any: permission_1.permissionDeniedAny, permission_denied_camera: permission_1.permissionDeniedCamera, permission_denied_motion: permission_1.permissionDeniedMotion, permission_request_motion: permission_1.permissionRequestMotion, permission_request_camera: permission_1.permissionRequestCamera, permission_request_all: permission_1.permissionRequestAll, permission_request_ui: permission_1.permissionRequestUI, permission_request_ui_promise: permission_1.permissionRequestUI, permission_denied_ui: permission_1.permissionDeniedUI, browser_incompatible: compatibility_1.default.incompatible, browser_incompatible_ui: compatibility_1.default.incompatible_ui, log_level_set: l => {
            loglevel_1.setLogLevel(l);
            c.impl.log_level_set(l);
        } });
    return client;
}
exports.initialize = initialize;
function loadDefaultFaceModel(o) {
    return __awaiter(this, void 0, void 0, function* () {
        let url = require("file-loader!./face_tracking_model.zbin");
        if (url.default !== undefined)
            url = url.default;
        let data = yield fetch(url);
        let ab = yield data.arrayBuffer();
        client === null || client === void 0 ? void 0 : client.face_tracker_model_load_from_memory(o, ab);
    });
}
